
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PostgreSQL 学习笔记（全量合并版）</title>
<style>
:root{
  --bg: linear-gradient(135deg, #f9fafb, #e5ebf2);
  --card:#ffffff;
  --border:#cbd5e1;
  --text:#111827;
  --muted:#374151;
  --accent:#2563eb;
  --green:#16a34a;
  --orange:#ea580c;
  --red:#dc2626;
  --code:#f3f4f6;
}

  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
    font:16px/1.65 "Inter","Noto Sans SC","Noto Sans CJK SC","Segoe UI",system-ui,-apple-system,sans-serif;}
  a{color:var(--accent);text-decoration:none}
  a:hover{text-decoration:underline}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  header{margin-bottom:24px}
  h1{font-size:28px;letter-spacing:.3px;margin:0 0 8px 0}
  .meta{color:var(--muted);font-size:14px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
  .card{grid-column:1/-1;background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px}
  h2{font-size:22px;margin:4px 0 12px 0}
  h3{font-size:18px;margin:18px 0 8px 0}
  p{margin:8px 0}
  ul{margin:6px 0 12px 18px}
  code,kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", monospace}
  pre{background:var(--code);border:1px solid var(--border);border-radius:12px;padding:12px;overflow:auto}
  .tag{display:inline-block;border:1px solid var(--border);padding:2px 8px;border-radius:999px;color:var(--muted);font-size:12px;margin-right:8px}
  .ok{color:var(--green)} .warn{color:var(--orange)} .bad{color:var(--red)}
  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width: 760px){ .two-col{grid-template-columns:1fr;} }
  nav.toc{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:16px}
  nav.toc ol{margin:0 0 0 18px}
  nav.toc a{font-size:14px}
  .anchor{scroll-margin-top:80px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>PostgreSQL 学习笔记</h1>
    </header>

    <nav class="toc card">
      <strong>目录</strong>
      <ol>
        <li><a href="#s1">SQL 执行顺序（通用）</a></li>
        <li><a href="#s2">字符串 / 正则表达式</a></li>
        <li><a href="#s3">日期时间与间隔：EXTRACT / INTERVAL / 时间差</a></li>
        <li><a href="#s4">TRUNCATE / ALTER TABLE（PostgreSQL 写法）</a></li>
        <li><a href="#s5">窗口函数与窗口帧</a></li>
        <li><a href="#s6">JOIN 全家桶</a></li>
        <li><a href="#s7">LIKE / ILIKE 与操作符</a></li>
        <li><a href="#s8">集合操作：UNION / INTERSECT / EXCEPT</a></li>
        <li><a href="#s9">GROUPING SETS / CUBE / ROLLUP</a></li>
        <li><a href="#s10">子查询：ANY / ALL / EXISTS / NOT EXISTS</a></li>
        <li><a href="#s11">CTE 与递归 CTE</a></li>
        <li><a href="#s12">DML：INSERT...SELECT / UPDATE...FROM / UPSERT</a></li>
        <li><a href="#s13">事务</a></li>
        <li><a href="#s14">创建数据库与对象大小</a></li>
        <li><a href="#s15">创建表、列/表级约束（PK/FK/UNIQUE/CHECK/NOT NULL）</a></li>
        <li><a href="#s16">SELECT INTO / CREATE TABLE AS</a></li>
        <li><a href="#s17">自增：SERIAL / SEQUENCE / IDENTITY（含管理）</a></li>
        <li><a href="#s18">ALTER TABLE / DROP TABLE</a></li>
        <li><a href="#s19">案例：按日统计售卖率（PostgreSQL 版）</a></li>
        <li><a href="#s20">DISTINCT ON（每组取一行）</a></li>
        <li><a href="#s21">分页：LIMIT/OFFSET 与锚点翻页</a></li>
        <li><a href="#s22">BOOLEAN（布尔类型）</a></li>
        <li><a href="#s23">字符数据类型</a></li>
        <li><a href="#s24">数值类型总览与函数</a></li>
        <li><a href="#s25">整数类型与 SERIAL（强化）</a></li>
        <li><a href="#s26">日期与时间数据类型（总览）</a></li>
        <li><a href="#s27">TIMESTAMP vs TIMESTAMPTZ</a></li>
        <li><a href="#s28">INTERVAL（时间间隔）</a></li>
        <li><a href="#s29">UUID</a></li>
        <li><a href="#s30">数组类型</a></li>
        <li><a href="#s31">JSON / JSONB</a></li>
        <li><a href="#s32">从 JSON 提取数值并聚合</a></li>
        <li><a href="#s33">Schema 管理</a></li>
        <li><a href="#s34">COALESCE</a></li>
        <li><a href="#s35">NULLIF</a></li>
        <li><a href="#s36">CAST / ::</a></li>
        <li><a href="#s37">CASE 表达式</a></li>
        <li><a href="#s38">删除重复数据（DELETE USING）</a></li>
        <li><a href="#s39">RANDOM()</a></li>
        <li><a href="#s40">EXPLAIN</a></li>
        <li><a href="#s41">PostgreSQL vs MySQL 对比</a></li>
        <li><a href="#s42">EXCEPT 补充</a></li>
        <li><a href="#s43">PL/pgSQL：块结构</a></li>
        <li><a href="#s44">PL/pgSQL：变量</a></li>
        <li><a href="#s45">PL/pgSQL：常量</a></li>
        <li><a href="#s46">创建函数与存储过程</a></li>
        <li><a href="#s47">函数参数四种模式</a></li>
        <li><a href="#s48">函数重载</a></li>
        <li><a href="#s49">使用函数返回一张表（RETURNS TABLE / RETURN QUERY / RETURN NEXT）</a></li>
        <li><a href="#s50">IF 判断语句</a></li>
        <li><a href="#s51">CASE 判断语句（简单 / 可搜索）</a></li>
        <li><a href="#s52">循环：LOOP / WHILE / FOR（含 EXIT / CONTINUE）</a></li>
        <li><a href="#s53">游标 Cursor：显式/隐式、FETCH/MOVE、CURRENT OF、示例</a></li>
        <li><a href="#s54">存储过程（PROCEDURE）：语法、事务控制、示例、异常处理</a></li>
        <li><a href="#s55">索引的创建</a></li>
        <li><a href="#s56">删除索引</a></li>
        <li><a href="#s57">查看索引的方式</a></li>
        <li><a href="#s58">索引类型</a></li>
        <li><a href="#s59">唯一索引</a></li>
        <li><a href="#s60">基于表达式的索引</a></li>
        <li><a href="#s61">局部索引（部分索引）</a></li>
        <li><a href="#s62">重新索引（REINDEX）</a></li>
        <li><a href="#s63">多列索引</a></li>
        <li><a href="#s64">视图管理</a></li>
        <li><a href="#s65">可更新视图</a></li>
        <li><a href="#s66">物理化视图</a></li>
        <li><a href="#s67">视图的 WITH CHECK OPTION</a></li>
        <li><a href="#s68">触发器介绍</a></li>
        <li><a href="#s69">触发器的创建</a></li>
        <li><a href="#s70">触发器的删除</a></li>
        <li><a href="#s71">触发器的管理</a></li>
        <li><a href="#s72">角色管理</a></li>
        <li><a href="#s73">数据库的备份</a></li>
        <li><a href="#s74">数据库的还原</a></li>
        <li><a href="#s75">表空间创建</a></li>
        <li><a href="#s76">表空间修改和删除</a></li>

      </ol>
    </nav>

    <section class="grid">

      <article class="card anchor" id="s1">
        <h2>1）SQL 执行顺序（通用，适用于 PostgreSQL）</h2>
        <p><span class="tag">FROM/ON</span> → <span class="tag">WHERE</span> → <span class="tag">GROUP BY</span> → <span class="tag">HAVING</span> → <span class="tag">SELECT（窗口函数在此阶段）</span> → <span class="tag">ORDER BY</span></p>
      </article>

<article class="card anchor" id="s2">
  <h2>2）字符串 / 正则表达式</h2>
  <ul>
    <li><b>字符串拼接：</b> <code>expr1 || expr2</code></li>
    <li><b>长度：</b> <code>char_length(text)</code>（字符数），<code>octet_length(text)</code>（字节数）；<code>length(text)</code> 等价于 <code>char_length</code></li>
  </ul>
  <pre><code>-- 取第一个匹配子串（等价 REGEXP_SUBSTR 的基本场景）
SELECT substring('abc-123-def' FROM '\d+');  -- → '123'

-- 全部匹配（返回 setof text）
SELECT regexp_matches('a1b22c333', '\d+', 'g');  -- 多行返回 1,22,333

-- 是否匹配
SELECT 'foo@example.com' ~ '^[^@]+@[^@]+$';  -- true/false
</code></pre>
  <section>
    <h3>PostgreSQL 正则表达式笔记</h3>

    <h4>常用函数</h4>
    <ul>
      <li><code>SUBSTRING('text' FROM '正则表达式')</code>  
        返回第一个匹配的第一个捕获分组内容（如果有分组），否则返回整个匹配的子串。</li>
      <li><code>REGEXP_matches('text', '正则表达式', 'g')</code>  
        返回所有匹配的结果（数组形式）。'g' 表示全局匹配。</li>
    </ul>

    <h4>常用正则符号</h4>
    <table>
      <tr><td><code>\d+</code></td><td>连续的数字</td></tr>
      <tr><td><code>[a-z]+</code></td><td>连续的小写字母</td></tr>
      <tr><td><code>[a-zA-Z]+</code></td><td>连续的大小写字母</td></tr>
      <tr><td><code>[a-z]+\d+</code></td><td>小写字母后接数字</td></tr>
      <tr><td><code>\w</code></td><td>等价 [a-zA-Z0-9_]</td></tr>
      <tr><td><code>\s+</code></td><td>一个或多个空白符</td></tr>
      <tr><td><code>.</code></td><td>任意单个字符（除换行）</td></tr>
      <tr><td><code>*</code></td><td>0 次或多次</td></tr>
      <tr><td><code>*?</code></td><td>非贪婪版本</td></tr>
      <tr><td><code>+</code></td><td>1 次或多次</td></tr>
      <tr><td><code>+?</code></td><td>非贪婪版本</td></tr>
      <tr><td><code>?</code></td><td>0 或 1 次</td></tr>
      <tr><td><code>{n,m}</code></td><td>n 到 m 次</td></tr>
    </table>

    <h4>锚点符号</h4>
    <ul>
      <li><code>^</code> 开头</li>
      <li><code>$</code> 结尾</li>
    </ul>

    <h4>字符集</h4>
    <p><code>[abc]</code> 匹配 a/b/c； <code>[^abc]</code> 匹配非 a/b/c</p>

    <h4>正则分组 () 与反向引用</h4>
    <p><code>(abc)+</code> 表示整体重复；<code>(\w+)\s+\1</code> 表示相同单词重复。</p>

    <h4>单词边界</h4>
    <p><code>\bthe\b</code> 匹配完整单词 "the"</p>

    <h4>贪婪 vs 非贪婪</h4>
    <pre><code><.*>   -- 贪婪，匹配 &lt;abc&gt;&lt;def&gt;
<.*?>  -- 非贪婪，匹配 &lt;abc&gt;
</code></pre>

    <h4>补充说明</h4>
    <ul>
      <li><code>substring()</code> 有分组时返回分组，无分组返回整个匹配。</li>
      <li><code>regexp_matches()</code> 可获取多个匹配，返回数组。</li>
      <li>多个分组时，<code>regexp_matches()</code> 会返回包含所有组的数组。</li>
    </ul>
  </section>
</article>


      <article class="card anchor" id="s3">
        <h2>3）日期时间与间隔：EXTRACT / INTERVAL / 时间差</h2>
        <div class="two-col">
          <div>
            <h3>时间差（替代 MySQL TIMESTAMPDIFF）</h3>
            <pre><code>-- 两个时间相减得到 interval
SELECT end_ts - start_ts AS diff;

-- 转分钟数
SELECT EXTRACT(EPOCH FROM (end_ts - start_ts)) / 60 AS minutes;
</code></pre>
          </div>
          <div>
            <h3>日期加减（替代 DATE_ADD / DATE_SUB）</h3>
            <pre><code>SELECT ts + INTERVAL '3 days';
SELECT ts - INTERVAL '2 hours';
SELECT CURRENT_DATE + INTERVAL '1 month';
</code></pre>
          </div>
        </div>
        <h3>EXTRACT</h3>
        <pre><code>SELECT EXTRACT(YEAR  FROM ts),
       EXTRACT(MONTH FROM ts),
       EXTRACT(DAY   FROM ts);
</code></pre>
      </article>

      <article class="card anchor" id="s4">
        <h2>4）TRUNCATE / ALTER TABLE（PostgreSQL 写法）</h2>
        <div class="two-col">
          <div>
            <h3>TRUNCATE</h3>
            <pre><code>TRUNCATE TABLE table_name RESTART IDENTITY;  -- 重置自增
-- 可选：CASCADE 级联
</code></pre>
          </div>
          <div>
            <h3>列操作（PostgreSQL 没有 MySQL 的 CHANGE/MODIFY/AFTER）</h3>
            <pre><code>-- 添加列
ALTER TABLE t ADD COLUMN name type;

-- 修改类型
ALTER TABLE t ALTER COLUMN name TYPE new_type;

-- 重命名列
ALTER TABLE t RENAME COLUMN old TO new;

-- 设置/取消默认值
ALTER TABLE t ALTER COLUMN name SET DEFAULT ...;
ALTER TABLE t ALTER COLUMN name DROP DEFAULT;

-- 非空/可空
ALTER TABLE t ALTER COLUMN name SET NOT NULL;
ALTER TABLE t ALTER COLUMN name DROP NOT NULL;
</code></pre>
          </div>
        </div>
      </article>

      <article class="card anchor" id="s5">
        <h2>5）窗口函数与窗口帧</h2>
        <h3>常用函数</h3>
        <p><code>SUM</code> / <code>AVG</code> / <code>COUNT</code> / <code>MIN</code> / <code>MAX</code>，<code>ROW_NUMBER</code>，<code>RANK</code>，<code>DENSE_RANK</code>，<code>NTILE(n)</code>，<code>FIRST_VALUE</code>，<code>LAST_VALUE</code>，<code>NTH_VALUE</code>，<code>LAG</code>，<code>LEAD</code></p>
        <h3>窗口帧（ROWS / RANGE）</h3>
        <pre><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
ROWS BETWEEN 3 PRECEDING AND CURRENT ROW

-- 基于值范围（日期/数值）
RANGE BETWEEN INTERVAL '30 days' PRECEDING AND CURRENT ROW
</code></pre>
      </article>

      <article class="card anchor" id="s6">
        <h2>6）JOIN 全家桶</h2>
        <ul>
          <li><b>INNER JOIN：</b> 仅保留匹配行</li>
          <li><b>LEFT JOIN：</b> 左表全部 + 右表匹配，右侧缺失填 NULL</li>
          <li><b>RIGHT JOIN：</b> 右表全部 + 左表匹配</li>
          <li><b>FULL OUTER JOIN：</b> 两侧所有行的并集（MySQL 不支持）</li>
          <li><b>CROSS JOIN：</b> 笛卡尔积</li>
          <li><b>NATURAL JOIN：</b> 同名列自动连接（不透明，生产不推荐）</li>
          <li><b>SELF JOIN：</b> 同表自连接（层级/对比/去重等）</li>
        </ul>
      </article>

      <article class="card anchor" id="s7">
        <h2>7）LIKE / ILIKE 与操作符</h2>
        <ul>
          <li><code>LIKE</code>（区分大小写），<code>ILIKE</code>（不区分大小写）</li>
          <li>等价操作符：<code>~~</code> / <code>!~~</code> / <code>~~*</code> / <code>!~~*</code>（常用写法仍建议 LIKE/ILIKE）</li>
        </ul>
      </article>

      <article class="card anchor" id="s8">
        <h2>8）集合操作：UNION / INTERSECT / EXCEPT</h2>
        <ul>
          <li><b>UNION</b>（去重） / <b>UNION ALL</b>（不去重）</li>
          <li><b>INTERSECT</b>（交集，去重；<code>INTERSECT ALL</code> 保留重复）</li>
          <li><b>EXCEPT</b>（差集，去重；<code>EXCEPT ALL</code> 保留重复）</li>
        </ul>
      </article>

      <article class="card anchor" id="s9">
        <h2>9）GROUPING SETS / CUBE / ROLLUP</h2>
        <pre><code>-- GROUPING SETS：一个查询中进行多种分组
SELECT region, product, SUM(sales)
FROM fact
GROUP BY GROUPING SETS ((region, product), (region), ());

-- CUBE：所有维度的全组合
SELECT region, product, SUM(sales)
FROM fact
GROUP BY CUBE (region, product);

-- ROLLUP：逐级汇总（细 → 粗）
SELECT y, m, SUM(sales)
FROM fact
GROUP BY ROLLUP (y, m);
</code></pre>
      </article>

      <article class="card anchor" id="s10">
        <h2>10）子查询：ANY / ALL / EXISTS / NOT EXISTS</h2>
        <pre><code>-- = ANY 等价于 IN
x = ANY (SELECT id FROM t)

-- &gt; ANY 大于集合最小值； &lt; ANY 小于集合最大值
x &gt; ANY (SELECT val FROM t)

-- ALL：与集合全部比较都成立
x &gt; ALL (SELECT val FROM t)

-- EXISTS：子查询返回至少一行即为 true
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id)

-- NOT EXISTS：查“孤儿数据”
</code></pre>
      </article>

      <article class="card anchor" id="s11">
        <h2>11）CTE 与递归 CTE</h2>
        <pre><code>-- 普通 CTE
WITH c AS (
  SELECT ... FROM ...
)
SELECT * FROM c;

-- 递归 CTE（树/图/层级）
WITH RECURSIVE cte_name AS (
  -- ① 基础查询（起点）
  SELECT ...
  FROM table
  WHERE ...
  UNION ALL
  -- ② 递归部分（自我引用）
  SELECT ...
  FROM table t
  JOIN cte_name c ON t.parent_id = c.id
)
SELECT * FROM cte_name;
</code></pre>
        <ul>
          <li>组织架构、目录树、图遍历、层级路径/深度计算等</li>
        </ul>
      </article>

      <article class="card anchor" id="s12">
        <h2>12）DML：INSERT...SELECT / UPDATE...FROM / UPSERT</h2>
        <div class="two-col">
          <div>
            <h3>INSERT ... SELECT</h3>
            <pre><code>INSERT INTO table(col1, col2)
SELECT col1, col2
FROM another_table
WHERE condition;</code></pre>
          </div>
          <div>
            <h3>UPDATE ... FROM（联表更新）</h3>
            <pre><code>UPDATE a
SET val = b.val
FROM b
WHERE a.id = b.id;</code></pre>
          </div>
        </div>
        <h3>UPSERT（ON CONFLICT）</h3>
        <pre><code>ON CONFLICT ... DO NOTHING  -- 有冲突就跳过
ON CONFLICT ... DO UPDATE   -- 有冲突就更新（EXCLUDED）</code></pre>
      </article>

      <article class="card anchor" id="s13">
        <h2>13）事务</h2>
        <pre><code>BEGIN;   -- BEGIN WORK; / BEGIN TRANSACTION;
  -- DML ...
COMMIT;  -- COMMIT WORK; / COMMIT TRANSACTION;
-- 或者
ROLLBACK;  -- ROLLBACK WORK; / ROLLBACK TRANSACTION;
</code></pre>
      </article>

      <article class="card anchor" id="s14">
        <h2>14）创建数据库与对象大小</h2>
        <h3>创建数据库</h3>
        <pre><code>CREATE DATABASE db_name
  OWNER = role_name
  ENCODING = 'UTF8'
  LC_COLLATE = 'C'
  LC_CTYPE = 'C'
  TABLESPACE = pg_default
  CONNECTION LIMIT = -1;
</code></pre>
        <h3>对象大小</h3>
        <pre><code>SELECT pg_size_pretty(pg_relation_size('table_name'));         -- 表
SELECT pg_size_pretty(pg_total_relation_size('table_name'));   -- 表(含索引/TOAST)
SELECT pg_size_pretty(pg_database_size(current_database()));    -- 库
</code></pre>
      </article>

      <article class="card anchor" id="s15">
        <h2>15）创建表、列/表级约束（PK/FK/UNIQUE/CHECK/NOT NULL）</h2>
        <h3>CREATE TABLE（语法骨架）</h3>
        <pre><code>CREATE TABLE 表名 (
  列名 数据类型 [列的约束],
  [表的约束]
)
INHERITS (已有的表名);  -- 可选：继承
</code></pre>
        <h3>列级约束示例</h3>
        <pre><code>name TEXT NOT NULL
email TEXT UNIQUE
age INTEGER CHECK (age &gt;= 18)
id SERIAL PRIMARY KEY
</code></pre>
        <h3>表级约束示例</h3>
        <pre><code>PRIMARY KEY (id, dept_id)          -- 复合主键
UNIQUE (email, phone)              -- 复合唯一
CHECK (start_date &lt; end_date)      -- 跨列检查
FOREIGN KEY (user_id) REFERENCES users(id)</code></pre>

        <h3 id="s15-pk">PRIMARY KEY（主键）</h3>
        <pre><code>-- 方式 1：单列主键（字段后直接写）
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);

-- 方式 2：显式命名（推荐）
CREATE TABLE users (
  id INTEGER,
  name TEXT,
  CONSTRAINT users_pkey PRIMARY KEY (id)
);

-- 方式 3：联合主键
CREATE TABLE order_items (
  order_id INTEGER,
  item_id  INTEGER,
  CONSTRAINT order_items_pkey PRIMARY KEY (order_id, item_id)
);

-- 方式 4/5：ALTER TABLE 添加主键 / 添加带 SERIAL 的主键列
ALTER TABLE users ADD CONSTRAINT users_pkey PRIMARY KEY (id);
</code></pre>
        <p class="meta">注意：主键列不可为 NULL；添加前需确保数据无重复/NULL；删除主键用 <code>ALTER TABLE ... DROP CONSTRAINT</code>。</p>

        <h3 id="s15-fk">FOREIGN KEY（外键）</h3>
        <pre><code>-- CREATE TABLE 内定义（命名版）
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER,
  CONSTRAINT orders_user_fk FOREIGN KEY (user_id) REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

-- 字段后简写（不命名）
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id)
);

-- 已有表添加外键（推荐显式命名）
ALTER TABLE orders
ADD CONSTRAINT orders_user_fk FOREIGN KEY (user_id) REFERENCES users(id);
</code></pre>
        <p class="meta">ON DELETE/UPDATE：CASCADE / SET NULL / RESTRICT / NO ACTION 等。</p>

        <h3 id="s15-uniq">UNIQUE（唯一约束）</h3>
        <pre><code>-- 列级唯一
email TEXT UNIQUE

-- 表级唯一（命名）
CONSTRAINT unique_email UNIQUE (email)

-- 复合唯一
CONSTRAINT unique_user_email UNIQUE (user_id, email_type)</code></pre>
        <p class="meta">唯一约束允许多个 <code>NULL</code>；自动创建唯一索引。</p>

        <h3 id="s15-check">CHECK（检查约束）</h3>
        <pre><code>age INTEGER CHECK (age BETWEEN 18 AND 65)
salary NUMERIC CHECK (salary &gt; 0)
CHECK (start_date &lt; end_date)
-- 处理 NULL：CHECK (age IS NULL OR age &gt;= 18)</code></pre>

        <h3 id="s15-notnull">NOT NULL（非空）</h3>
        <pre><code>-- 创建时定义
name TEXT NOT NULL

-- 已有表添加/取消
ALTER TABLE users ALTER COLUMN name SET NOT NULL;
ALTER TABLE users ALTER COLUMN name DROP NOT NULL;</code></pre>
      </article>

      <article class="card anchor" id="s16">
        <h2>16）SELECT INTO / CREATE TABLE AS</h2>
        <pre><code>-- 直接用查询结果建表
SELECT * INTO backup_users
FROM users
WHERE is_active = true;

-- 推荐标准写法（更可控）
CREATE TABLE backup_users AS
SELECT * FROM users WHERE is_active = true;</code></pre>
        <p class="meta"><code>SELECT INTO</code> 只能创建新表；插入已有表请用 <code>INSERT INTO ... SELECT ...</code>。</p>
      </article>

      <article class="card anchor" id="s17">
        <h2>17）自增：SERIAL / SEQUENCE / IDENTITY（含管理）</h2>
        <div class="two-col">
          <div>
            <h3>SERIAL（三种）</h3>
            <ul>
              <li><code>SMALLSERIAL</code> → <code>smallint</code></li>
              <li><code>SERIAL</code> → <code>integer</code></li>
              <li><code>BIGSERIAL</code> → <code>bigint</code></li>
            </ul>
            <p class="meta">默认起始值：1；SERIAL 是快捷方式，会创建序列并设默认值。</p>
          </div>
          <div>
            <h3>IDENTITY（SQL 标准，推荐）</h3>
            <pre><code>id INTEGER GENERATED ALWAYS AS IDENTITY
-- 或：BY DEFAULT AS IDENTITY
-- 可选项：START WITH / INCREMENT BY / MINVALUE / MAXVALUE / CYCLE / CACHE</code></pre>
          </div>
        </div>
        <h3>序列（SEQUENCE）</h3>
        <pre><code>CREATE SEQUENCE mysequence INCREMENT 5 START 100;
-- OWNED BY：绑定到表列，删除列/表时自动删除序列
SELECT nextval('mysequence');  -- 100, 105, ...
-- 查询所有序列名
SELECT c.relname AS sequence_name FROM pg_class c WHERE c.relkind = 'S';
-- 删除序列
DROP SEQUENCE IF EXISTS mysequence CASCADE;</code></pre>
        <h3>为已有列添加/修改/删除 IDENTITY</h3>
        <pre><code>ALTER TABLE t ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE t ALTER COLUMN id SET GENERATED BY DEFAULT;
ALTER TABLE t ALTER COLUMN id SET (START WITH 1000, INCREMENT BY 10);
ALTER TABLE t ALTER COLUMN id DROP IDENTITY;</code></pre>
      </article>

      <article class="card anchor" id="s18">
        <h2>18）ALTER TABLE / DROP TABLE</h2>
        <pre><code>-- 多操作合并
ALTER TABLE users
  ADD COLUMN email TEXT,
  DROP COLUMN temp_data,
  RENAME COLUMN full_name TO name;

-- 删除表
DROP TABLE users;
DROP TABLE orders, products;
DROP TABLE IF EXISTS temp_data;   -- 安全删除
DROP TABLE orders CASCADE;        -- 连同依赖</code></pre>
      </article>

      <article class="card anchor" id="s19">
        <h2>19）案例：按日统计售卖率（PostgreSQL 版）</h2>
        <pre><code>SELECT
  DATE '2021-10-01' AS dt,
  ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-25' AND DATE '2021-10-01') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3) AS sale_rate,
  1 - ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-25' AND DATE '2021-10-01') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3) AS unsale_rate
FROM tb_product_info t1
LEFT JOIN tb_order_detail  t2 ON t1.product_id = t2.product_id
LEFT JOIN tb_order_overall t3 ON t2.order_id   = t3.order_id
WHERE shop_id = 901

UNION ALL

SELECT
  DATE '2021-10-02',
  ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-26' AND DATE '2021-10-02') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3),
  1 - ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-26' AND DATE '2021-10-02') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3)
FROM tb_product_info t1
LEFT JOIN tb_order_detail  t2 ON t1.product_id = t2.product_id
LEFT JOIN tb_order_overall t3 ON t2.order_id   = t3.order_id
WHERE shop_id = 901

UNION ALL

SELECT
  DATE '2021-10-03',
  ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-27' AND DATE '2021-10-03') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3),
  1 - ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-27' AND DATE '2021-10-03') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3)
FROM tb_product_info t1
LEFT JOIN tb_order_detail  t2 ON t1.product_id = t2.product_id
LEFT JOIN tb_order_overall t3 ON t2.order_id   = t3.order_id
WHERE shop_id = 901
ORDER BY 1;
</code></pre>
      </article>

      <article class="card anchor" id="s20">
        <h2>20）DISTINCT ON（每组取一行）</h2>
        <pre><code>-- 取每个 user_id 的最新一条记录
SELECT DISTINCT ON (user_id) *
FROM logs
ORDER BY user_id, created_at DESC;
</code></pre>
        <p class="meta">必须结合合适的 <code>ORDER BY</code> 确定每组保留行。</p>
      </article>

      <article class="card anchor" id="s21">
        <h2>21）分页：LIMIT/OFFSET 与锚点翻页</h2>
        <pre><code>-- 传统分页（大偏移性能差）
SELECT ... ORDER BY id LIMIT 20 OFFSET 2000;

-- 锚点式（更高效，基于上次最后一条的 id）
SELECT ... WHERE id &gt; :last_id ORDER BY id LIMIT 20;
</code></pre>
      </article>

      <article class="card anchor" id="s22">
        <h2>22）布尔数据类型（BOOLEAN）</h2>
        <pre><code>CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  is_active BOOLEAN
);

-- 合法写法
INSERT INTO users(is_active) VALUES (TRUE);
INSERT INTO users(is_active) VALUES ('t');
INSERT INTO users(is_active) VALUES (FALSE);

-- 查询
SELECT * FROM users WHERE is_active;        -- 等价于 is_active = TRUE
</code></pre>
        <p class="meta">布尔值等价写法：<code>true/t/yes/y/1</code> 与 <code>false/f/no/n/0</code>；<code>NULL</code> 表示未知。</p>
      </article>

      <article class="card anchor" id="s23">
        <h2>23）字符数据类型</h2>
        <h3>主要类型</h3>
        <ul>
          <li><b>TEXT</b>：不限制长度，推荐</li>
          <li><b>VARCHAR(n)</b>：最大长度为 n，超长插入失败</li>
          <li><b>CHAR(n)</b>：定长，不足补空格（很少使用）</li>
        </ul>
        <pre><code>CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(30),
  full_name TEXT,
  gender CHAR(1)
);

INSERT INTO users (username, full_name, gender)
VALUES ('alice', 'Alice Wonderland', 'F');
</code></pre>
        <h3>常用函数</h3>
        <pre><code>LENGTH(str) / char_length(str)
TRIM(str) / LOWER(str) / UPPER(str)
SUBSTRING(str FROM x FOR y)
CONCAT(a, b)
-- 不区分大小写匹配：ILIKE</code></pre>
      </article>

      <article class="card anchor" id="s24">
        <h2>24）数值类型总览与函数</h2>
        <h3>整数</h3>
        <ul>
          <li><code>SMALLINT</code> / <code>INTEGER</code> / <code>BIGINT</code></li>
        </ul>
        <h3>浮点</h3>
        <ul>
          <li><code>REAL</code>（约 6 位），<code>DOUBLE PRECISION</code>（约 15 位）</li>
        </ul>
        <h3>定点/高精度</h3>
        <ul>
          <li><code>NUMERIC(p, s)</code> / <code>DECIMAL(p, s)</code>（别名）— 金额推荐</li>
        </ul>
        <h3>常用函数/转换</h3>
        <pre><code>ROUND(n, d), CEIL(n), FLOOR(n), ABS(n), POWER(x,y), MOD(x,y)
CAST(... AS type), '123'::INTEGER</code></pre>
        <p class="meta">金融金额类请用 <code>NUMERIC</code>，避免浮点误差。</p>
      </article>

      <article class="card anchor" id="s25">
        <h2>25）整数类型与 SERIAL（强化）</h2>
        <pre><code>CREATE TABLE numbers (
  small_number SMALLINT,
  normal_number INTEGER,
  big_number BIGINT
);

-- 自增（伪类型）
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);
</code></pre>
        <p class="meta">选择建议：小范围 <code>SMALLINT</code>、常用 <code>INTEGER</code>、极大范围 <code>BIGINT</code>。</p>
      </article>

      <article class="card anchor" id="s26">
        <h2>26）日期与时间数据类型（总览）</h2>
        <ul>
          <li><code>DATE</code>、<code>TIME</code>、<code>TIME WITH TIME ZONE</code></li>
          <li><code>TIMESTAMP</code>、<code>TIMESTAMPTZ</code>（带时区）</li>
          <li><code>INTERVAL</code>（时间间隔）</li>
        </ul>
        <pre><code>CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  title TEXT,
  event_date DATE,
  start_time TIME,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 常用
SELECT CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, NOW();
SELECT NOW() + INTERVAL '3 days';

-- 格式化
SELECT to_char(NOW(), 'YYYY-MM-DD HH24:MI:SS');
</code></pre>
      </article>

      <article class="card anchor" id="s27">
        <h2>27）两种时间戳：TIMESTAMP vs TIMESTAMPTZ</h2>
        <pre><code>-- TIMESTAMP：不含时区，原样存储；适合本地事件
-- TIMESTAMPTZ：含时区，UTC 存储、显示按会话时区；适合日志/跨区

SHOW TIME ZONE;
SET TIME ZONE 'Asia/Shanghai';

-- 示例对比（假设系统时区 UTC+8）
-- t1: TIMESTAMP
INSERT INTO t1 (created_at) VALUES ('2025-09-02 14:00:00');  -- 存/显均 14:00:00

-- t2: TIMESTAMPTZ
INSERT INTO t2 (created_at) VALUES ('2025-09-02 14:00:00+08');
-- 实际以 UTC 存 06:00:00，显示为 14:00:00+08
</code></pre>
      </article>

      <article class="card anchor" id="s28">
        <h2>28）INTERVAL（时间间隔）</h2>
        <pre><code>INTERVAL '1 year 2 months 3 days'
INTERVAL '4 hours 30 minutes'

CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  event_name TEXT NOT NULL,
  duration INTERVAL NOT NULL
);

SELECT NOW() + INTERVAL '1 day';
SELECT NOW() - INTERVAL '2 hours';</code></pre>
      </article>

      <article class="card anchor" id="s29">
        <h2>29）UUID</h2>
        <pre><code>CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  username TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE
);

-- 生成函数：uuid_generate_v1(), uuid_generate_v4(), pgcrypto: gen_random_uuid()
</code></pre>
      </article>

      <article class="card anchor" id="s30">
        <h2>30）数组类型</h2>
        <pre><code>CREATE TABLE example (
  id SERIAL PRIMARY KEY,
  tags   TEXT[],
  scores INTEGER[]
);

INSERT INTO example (tags, scores) VALUES
('{red,green,blue}', '{100,90,80}');

-- 访问与函数
SELECT tags[1] FROM example;
SELECT array_length(scores, 1) FROM example;
SELECT unnest(tags) FROM example;

-- 更新元素
UPDATE example SET tags[2] = 'yellow' WHERE id = 1;</code></pre>
      </article>

      <article class="card anchor" id="s31">
        <h2>31）JSON / JSONB</h2>
        <pre><code>CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  data JSONB NOT NULL
);

INSERT INTO documents (data)
VALUES ('{"name": "Alice", "age": 30, "skills": ["SQL", "Python"]}');

-- 提取
SELECT data->>'name' AS name FROM documents;   -- 文本
SELECT data->'skills' AS skills FROM documents;-- JSON

-- 查询包含
SELECT * FROM documents WHERE data @> '{"age": 30}';

-- 更新
UPDATE documents
SET data = jsonb_set(data, '{age}', '31', false)
WHERE id = 1;
</code></pre>
      </article>

      <article class="card anchor" id="s32">
        <h2>32）从 JSON 提取数值并聚合</h2>
        <pre><code>SELECT
  MIN((info->'items'->>'qty')::INTEGER),
  MAX((info->'items'->>'qty')::INTEGER),
  SUM((info->'items'->>'qty')::INTEGER),
  AVG((info->'items'->>'qty')::INTEGER)
FROM orders;
</code></pre>
      </article>

      <article class="card anchor" id="s33">
        <h2>33）Schema 管理</h2>
        <pre><code>-- PostgreSQL 不支持直接重命名 Schema
-- 实现“改名”：新建 + 迁移对象 + 删除旧的
CREATE SCHEMA new_schema_name;

ALTER TABLE old_schema.table_name SET SCHEMA new_schema_name;

DROP SCHEMA old_schema_name [CASCADE | RESTRICT];

ALTER SCHEMA schema_name OWNER TO new_owner;

SET search_path TO schema1, schema2, public;</code></pre>
      </article>

      <article class="card anchor" id="s34">
        <h2>34）COALESCE 笔记</h2>
        <pre><code>-- 简介
-- COALESCE(expr1, expr2, ..., exprN) 返回参数中第一个非 NULL 的值；
-- 常用于为可能为 NULL 的字段设置默认值；
-- 相当于：如果 A 是 NULL 就用 B，否则用 A。

-- 基本语法
COALESCE(value1, value2, ..., valueN)

-- 使用示例
-- 1. 字段为空时显示默认值
SELECT COALESCE(nickname, '无昵称') AS display_name
FROM users;

-- 等价：CASE
SELECT
  CASE
    WHEN nickname IS NOT NULL THEN nickname
    ELSE '无昵称'
  END AS display_name
FROM users;

-- 2. 多字段择一显示（昵称优先，用户名次之）
SELECT COALESCE(nickname, username, '匿名用户') AS display_name
FROM users;

-- 3. 聚合时处理 NULL，防止结果为 NULL
SELECT COALESCE(SUM(score), 0) AS total_score
FROM users;

-- 4. 搭配 NULLIF 使用，替换指定无效值（如 0）为 NULL
SELECT COALESCE(NULLIF(age, 0), 18) AS valid_age
FROM users;

-- 注意事项
-- - 可传入多个参数，按顺序返回第一个非 NULL；
-- - 返回类型为所有参数中数据类型“优先级最高”的类型；
-- - 一旦遇到非 NULL 值，后续参数不再评估（短路机制）；
-- - 可与 NULLIF 结合使用，逻辑更灵活。
</code></pre>
      </article>

      <article class="card anchor" id="s35">
        <h2>35）NULLIF 函数笔记</h2>
        <pre><code>-- 简介
-- NULLIF(expr1, expr2) 如果 expr1 = expr2，则返回 NULL；否则返回 expr1；
-- 常用于避免除以零错误、与 COALESCE 搭配处理特殊值等。

-- 基本语法
NULLIF(value1, value2)

-- 使用示例
-- 1. 避免除以零错误
SELECT total / NULLIF(count, 0) AS avg_value
FROM stats;

-- 2. 与 COALESCE 结合使用：把 0 当作 NULL 处理
SELECT COALESCE(NULLIF(age, 0), 18) AS valid_age
FROM users;

-- 3. 判断两个字段值是否相同
SELECT NULLIF(email, backup_email) AS email_if_different
FROM users;

-- 典型应用
-- 1) 处理非法值（如 0、空字符串）：NULLIF(some_field, 0) → 方便后续 COALESCE
-- 2) 避免运算错误（除以 0）
-- 3) 简化 CASE 判断
-- 注意：若两参数任一为 NULL，则不会返回 NULL，需注意判断逻辑。
</code></pre>
      </article>

      <article class="card anchor" id="s36">
        <h2>36）CAST 笔记</h2>
        <pre><code>-- 用途：将一种数据类型转换成另一种
CAST ( expression AS target_data_type )

-- 示例
SELECT CAST('123' AS INTEGER);
SELECT CAST(123 AS TEXT);
SELECT CAST('2025-09-05' AS DATE);

-- 简写
expression::target_data_type
SELECT '123'::INTEGER;
SELECT 123::TEXT;

-- 注意
-- - 转换失败会抛错，例如 'abc'::INTEGER
-- - 有些转换自动发生（整型↔浮点）
-- 场景：类型不匹配、算术前转换、格式化输出

SELECT
  id,
  price::TEXT AS price_text,
  CAST(created_at AS DATE) AS created_date
FROM products;
</code></pre>
      </article>

      <article class="card anchor" id="s37">
        <h2>37）CASE 表达式简化笔记</h2>
        <pre><code>CASE expression
  WHEN value_1 THEN result_1
  WHEN value_2 THEN result_2
  ...
  ELSE result_n
END

-- 示例
SELECT
  CASE status
    WHEN 'A' THEN 'Active'
    WHEN 'I' THEN 'Inactive'
    ELSE 'Unknown'
  END AS status_desc
FROM users;
</code></pre>
      </article>

      <article class="card anchor" id="s38">
        <h2>38）删除重复数据（DELETE USING 自连接）</h2>
        <pre><code>DELETE
FROM basket a
USING basket b
WHERE
  a.id &lt; b.id            -- 保留 id 较小的
  AND a.fruit = b.fruit; -- 重复判定条件
</code></pre>
        <p class="meta">说明：利用自连接删除重复；条件按业务自定义。</p>
      </article>

      <article class="card anchor" id="s39">
        <h2>39）RANDOM() 产生范围随机数</h2>
        <pre><code>-- RANDOM() 返回 [0,1) 浮点

-- [min, max) 浮点
SELECT RANDOM() * (max - min) + min;

-- [min, max] 整数
SELECT FLOOR(RANDOM() * (max - min + 1)) + min;

-- 示例
SELECT RANDOM() * (20 - 10) + 10;
SELECT FLOOR(RANDOM() * 100) + 1;
</code></pre>
        <p class="meta">需要整数可使用 <code>FLOOR</code> 或显式转换。</p>
      </article>

      <article class="card anchor" id="s40">
        <h2>40）EXPLAIN 语法笔记</h2>
        <pre><code>EXPLAIN [(option [, ...])] sql_statement;

-- 选项
ANALYZE [boolean]
VERBOSE [boolean]
COSTS [boolean]     -- 默认 true
BUFFERS [boolean]
TIMING [boolean]
SUMMARY [boolean]
FORMAT [TEXT|XML|JSON|YAML] -- 默认 TEXT

-- 示例
EXPLAIN ANALYZE VERBOSE SELECT * FROM users WHERE age &gt; 30;

-- 输出常见内容：节点类型（Seq Scan/Index Scan）、估计行数/成本、过滤条件、
-- 实际执行时间（ANALYZE）、缓冲区（BUFFERS）等。
</code></pre>
      </article>

      <article class="card anchor" id="s41">
        <h2>41）PostgreSQL 和 MySQL 对比笔记</h2>
        <pre><code>1. 基本定位
- PostgreSQL：开源对象-关系型数据库，强调标准、扩展性和复杂查询能力。
- MySQL：开源关系型数据库，强调速度、简单与广泛应用。

2. SQL 标准支持
- PostgreSQL：支持更全面（窗口函数、CTE、子查询等）。
- MySQL：旧版本支持较弱。

3. 数据完整性
- PostgreSQL：CHECK、外键、触发器、约束完善。
- MySQL：依引擎差异明显。

4. 并发控制
- PostgreSQL：MVCC 更彻底。
- MySQL：InnoDB 也支持 MVCC。

5. JSON 支持
- PostgreSQL：JSON/JSONB 强大。
- MySQL：5.7 起支持 JSON，功能较弱。

6. 扩展性
- PostgreSQL：自定义函数、类型、索引丰富。
- MySQL：相对较弱。

7. 性能
- PostgreSQL：复杂查询/OLAP 更优。
- MySQL：高并发小查询更轻快。

8. GIS 支持
- PostgreSQL：PostGIS 功能强。
- MySQL：较有限。

9. 工具 & 社区
- MySQL：生态成熟。
- PostgreSQL：社区活跃，增长快。

10. 应用场景
- 选 PG：一致性强、复杂查询、多维分析。
- 选 MySQL：中小型、Web、读多写少。
</code></pre>
      </article>

      <article class="card anchor" id="s42">
        <h2>42）EXCEPT 补充笔记</h2>
        <pre><code>-- 基本语法：
SELECT column1, column2, ...
FROM table1
EXCEPT
SELECT column1, column2, ...
FROM table2;

-- 示例：找出 foo 表中存在但 bar 表中不存在的记录
SELECT ID, name FROM foo
EXCEPT
SELECT ID, name FROM bar;

-- 特点：
-- 1) 默认去重；EXCEPT ALL 保留重复
-- 2) 两个 SELECT 的列数、顺序、类型需一致
-- 3) 常用于数据差异分析、同步校验
</code></pre>
      </article>

      <article class="card anchor" id="s43">
        <h2>43）PL/pgSQL：块结构笔记</h2>
        <pre><code>[ &lt;&lt;label&gt;&gt; ]
DECLARE
    declarations;
BEGIN
    statements;
END [label];

-- 示例
DO $$
DECLARE
  counter INTEGER := 0;
BEGIN
  FOR counter IN 1..5 LOOP
    RAISE NOTICE 'Counter: %', counter;
  END LOOP;
END;
$$;

-- 说明：DECLARE 可选；BEGIN...END 必须；可嵌套；label 可用于流程控制；可带 EXCEPTION。
</code></pre>
      </article>

      <article class="card anchor" id="s44">
        <h2>44）PL/pgSQL：变量笔记</h2>
        <pre><code>-- 声明
DECLARE
  var_name data_type [ := initial_value ];

-- 示例
DECLARE
  user_id INTEGER := 1001;
  user_name TEXT;
  is_active BOOLEAN := TRUE;

-- 使用与赋值
BEGIN
  user_name := 'Alice';
  RAISE NOTICE '用户名：%', user_name;
END;

-- 特殊变量
-- FOUND, SQLSTATE, SQLERRM

-- 赋值方式
total := price * quantity;
SELECT name INTO user_name FROM users WHERE id = user_id;

-- 完整 DO 块
DO $$
DECLARE
  counter INTEGER := 1;
  result  TEXT;
BEGIN
  WHILE counter &lt;= 3 LOOP
    result := '当前值: ' || counter;
    RAISE NOTICE '%', result;
    counter := counter + 1;
  END LOOP;
END;
$$;
</code></pre>
      </article>

      <article class="card anchor" id="s45">
        <h2>45）PL/pgSQL：常量笔记</h2>
        <pre><code>-- 声明
DECLARE
  constant_name CONSTANT data_type := value;

-- 示例
DECLARE
  pi CONSTANT NUMERIC := 3.1415926535;
  max_retry CONSTANT INTEGER := 5;

-- 特点：必须初始化且不可更改；提升可读性与安全性；常用大写命名。
-- 场景：固定配置、数学常量、系统级不变参数。
</code></pre>
      </article>

      <article class="card anchor" id="s46">
        <h2>46）创建存储过程/函数 笔记</h2>
        <pre><code>-- 创建函数
CREATE [OR REPLACE] FUNCTION function_name(parameter_list)
RETURNS return_data_type AS $$
BEGIN
  -- 函数体
  RETURN some_value;
END;
$$ LANGUAGE plpgsql;

-- 示例：
CREATE OR REPLACE FUNCTION get_five()
RETURNS INTEGER AS $$
BEGIN
  RETURN 5;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION add_numbers(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
BEGIN
  RETURN a + b;
END;
$$ LANGUAGE plpgsql;

-- 存储过程（PG 11+）
CREATE [OR REPLACE] PROCEDURE procedure_name(parameter_list)
LANGUAGE plpgsql AS $$
BEGIN
  -- 不返回值，可做事务控制
END;
$$;

-- 调用
SELECT function_name(args);
CALL procedure_name(args);
</code></pre>
      </article>

      <article class="card anchor" id="s47">
        <h2>47）函数的四种参数 笔记</h2>
        <pre><code>-- 1. IN（默认）
CREATE FUNCTION example_in(IN param1 INT)
RETURNS VOID AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;

-- 2. OUT
CREATE FUNCTION example_out(OUT result INT)
AS $$ BEGIN result := 100; END; $$ LANGUAGE plpgsql;

-- 3. INOUT
CREATE FUNCTION example_inout(INOUT param INT)
AS $$ BEGIN param := param + 10; END; $$ LANGUAGE plpgsql;

-- 4. VARIADIC（可变参=数组）
CREATE FUNCTION example_variadic(VARIADIC nums INT[])
RETURNS INT AS $$
DECLARE total INT := 0; n INT;
BEGIN
  FOREACH n IN ARRAY nums LOOP
    total := total + n;
  END LOOP;
  RETURN total;
END;
$$ LANGUAGE plpgsql;
</code></pre>
      </article>

      <article class="card anchor" id="s48">
        <h2>48）函数重载 笔记</h2>
        <pre><code>-- 定义多个同名不同参数列表的函数
CREATE FUNCTION add_value(a INT) RETURNS INT AS $$ BEGIN RETURN a + 10; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION add_value(a INT, b INT) RETURNS INT AS $$ BEGIN RETURN a + b; END; $$ LANGUAGE plpgsql;

-- 调用
SELECT add_value(5);      -- 15（单参版本）
SELECT add_value(5, 3);   -- 8  （双参版本）

-- 注意：区分依据是参数数量/类型；返回类型不同不能单独区分；
-- 自动类型转换可能影响匹配到的重载版本。
</code></pre>
      </article>
      <!-- 49）使用函数返回一张表 -->
<article class="card anchor" id="s49">
  <h2>49）使用函数返回一张表（RETURNS TABLE / RETURN QUERY / RETURN NEXT）</h2>
  <p>适用于封装复杂查询并参数化调用；返回结果可 <code>SELECT * FROM func()</code> 像表一样查询。</p>
  <h3>基本语法</h3>
  <pre><code>CREATE OR REPLACE FUNCTION function_name(param_list)
RETURNS TABLE (
    column1 datatype,
    column2 datatype,
    ...
)
AS $$
BEGIN
    RETURN QUERY
    SELECT ...
    FROM ...;
END;
$$ LANGUAGE plpgsql;
</code></pre>

  <ul>
    <li><code>RETURNS TABLE(...)</code>：定义“表格”结果。</li>
    <li><code>RETURN QUERY</code>：一次性返回整个查询集。</li>
    <li><code>RETURN NEXT</code>：配合循环逐行返回。</li>
  </ul>

  <h3>示例 1：RETURN QUERY</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_film(p_pattern VARCHAR)
RETURNS TABLE (
    film_title VARCHAR,
    film_release_year INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT title, CAST(release_year AS INTEGER)
    FROM film
    WHERE title LIKE p_pattern;
END;
$$ LANGUAGE plpgsql;

-- 调用
SELECT * FROM get_film('A%');
</code></pre>

  <h3>示例 2：LOOP + RETURN NEXT</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_film(p_pattern VARCHAR, p_year INT)
RETURNS TABLE (
    film_title VARCHAR,
    film_release_year INT
) AS $$
DECLARE
    var_r RECORD;
BEGIN
    FOR var_r IN
        SELECT title, release_year
        FROM film
        WHERE title LIKE p_pattern
          AND release_year = p_year
    LOOP
        film_title := UPPER(var_r.title);
        film_release_year := var_r.release_year;
        RETURN NEXT;  -- 逐行返回
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 调用
SELECT * FROM get_film('A%', 2006);
</code></pre>

  <h3>调用建议 &amp; 注意</h3>
  <ul>
    <li>推荐：<code>SELECT * FROM function_name(...)</code>；避免 <code>SELECT function_name(...)</code> 仅得一列复合类型。</li>
    <li><b>不要混用</b> <code>RETURN QUERY</code> 与 <code>RETURN NEXT</code>。</li>
    <li>复杂逐行处理用 <code>RETURN NEXT</code>；简单整集返回用 <code>RETURN QUERY</code>。</li>
  </ul>
</article>

<!-- 50）IF 判断语句 -->
<article class="card anchor" id="s50">
  <h2>50）IF 判断语句</h2>
  <h3>IF / IF ... ELSE / IF ... ELSIF ... ELSE</h3>
  <pre><code>-- IF
DO $$
DECLARE a int := 10; b int := 20;
BEGIN
  IF a &gt; b THEN
    RAISE NOTICE 'a is greater than b';
  END IF;
END $$;

-- IF ELSE
DO $$
DECLARE a int := 10; b int := 20;
BEGIN
  IF a &gt; b THEN
    RAISE NOTICE 'a is greater than b';
  ELSE
    RAISE NOTICE 'a is not greater than b';
  END IF;
END $$;

-- IF ELSIF ELSE
DO $$
DECLARE a int := 10; b int := 10;
BEGIN
  IF a &gt; b THEN
    RAISE NOTICE 'a is greater than b';
  ELSIF a &lt; b THEN
    RAISE NOTICE 'a is less than b';
  ELSE
    RAISE NOTICE 'a is equal to b';
  END IF;
END $$;
</code></pre>
</article>

<!-- 51）CASE 判断语句 -->
<article class="card anchor" id="s51">
  <h2>51）CASE 判断语句（简单 / 可搜索）</h2>
  <h3>1. 简单 CASE</h3>
  <pre><code>-- 语法（PL/pgSQL）
CASE search_expression
  WHEN expression_1 THEN statements
  WHEN expression_2 THEN statements
  ...
  ELSE statements
END CASE;

-- 示例：根据 film_id 获取 price_segment
CREATE OR REPLACE FUNCTION get_price_segment(p_film_id int)
RETURNS VARCHAR(50) AS $$
DECLARE
  rate NUMERIC;
  price_segment VARCHAR(50);
BEGIN
  SELECT rental_rate INTO rate
  FROM film
  WHERE film_id = p_film_id;

  CASE rate
    WHEN 0.99 THEN price_segment := 'Mass';
    WHEN 2.99 THEN price_segment := 'Mainstream';
    WHEN 4.99 THEN price_segment := 'High End';
    ELSE price_segment := 'Unspecified';
  END CASE;

  RETURN price_segment;
END;
$$ LANGUAGE plpgsql;
</code></pre>

  <h3>2. 可搜索 CASE</h3>
  <pre><code>CASE
  WHEN boolean_expr_1 THEN statements
  WHEN boolean_expr_2 THEN statements
  ...
  ELSE statements
END CASE;

-- 示例：根据 customer_id 获取 service_level
CREATE OR REPLACE FUNCTION get_customer_service (p_customer_id int)
RETURNS VARCHAR(25) AS $$
DECLARE
  total_payment NUMERIC;
  service_level VARCHAR(25);
BEGIN
  SELECT SUM(amount) INTO total_payment
  FROM payment
  WHERE customer_id = p_customer_id;

  CASE
    WHEN total_payment &gt; 200 THEN service_level := 'Platinum';
    WHEN total_payment &gt; 100 THEN service_level := 'Gold';
    ELSE service_level := 'Sliver';
  END CASE;

  RETURN service_level;
END;
$$ LANGUAGE plpgsql;

-- 调用示例
SELECT 148 AS customer, get_customer_service(148)
UNION
SELECT 178, get_customer_service(178)
UNION
SELECT 81 , get_customer_service(81);
</code></pre>
</article>

<!-- 52）循环：LOOP / WHILE / FOR -->
<article class="card anchor" id="s52">
  <h2>52）循环：LOOP / WHILE / FOR（含 EXIT / CONTINUE）</h2>
  <h3>LOOP（需 EXIT 退出）</h3>
  <pre><code>DO $$
DECLARE counter int := 0;
BEGIN
  LOOP
    counter := counter + 1;
    EXIT WHEN counter &gt; 5;
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;
</code></pre>

  <h3>WHILE</h3>
  <pre><code>DO $$
DECLARE counter int := 0;
BEGIN
  WHILE counter &lt; 5 LOOP
    counter := counter + 1;
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;
</code></pre>

  <h3>FOR（正向/反向）</h3>
  <pre><code>DO $$
DECLARE counter int;
BEGIN
  FOR counter IN 1..5 LOOP
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;

DO $$
DECLARE counter int;
BEGIN
  FOR counter IN REVERSE 5..1 LOOP
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;
</code></pre>

  <h3>EXIT / CONTINUE</h3>
  <pre><code>DO $$
DECLARE counter int := 0;
BEGIN
  LOOP
    counter := counter + 1;
    IF mod(counter, 2) = 0 THEN
      CONTINUE;  -- 跳过偶数
    END IF;
    RAISE NOTICE 'Odd Counter = %', counter;
    EXIT WHEN counter &gt;= 10;
  END LOOP;
END $$;
</code></pre>
</article>

<!-- 53）游标 Cursor -->
<article class="card anchor" id="s53">
  <h2>53）游标 Cursor：显式/隐式、FETCH/MOVE、CURRENT OF、示例</h2>
  <p>游标用于逐行处理查询结果。显式游标更灵活；隐式（<code>FOR ... IN SELECT</code>）更简洁。</p>

  <h3>显式游标示例</h3>
  <pre><code>DO $$
DECLARE
  cur_users CURSOR FOR SELECT id, name FROM users;
  v_id   users.id%TYPE;
  v_name users.name%TYPE;
BEGIN
  OPEN cur_users;
  LOOP
    FETCH cur_users INTO v_id, v_name;
    EXIT WHEN NOT FOUND;      -- FETCH 未取到行
    RAISE NOTICE 'ID: %, Name: %', v_id, v_name;
  END LOOP;
  CLOSE cur_users;
END $$;
</code></pre>

  <h3>隐式游标（FOR 循环）示例</h3>
  <pre><code>DO $$
DECLARE
  user_rec RECORD;
BEGIN
  FOR user_rec IN SELECT id, name FROM users LOOP
    RAISE NOTICE 'ID: %, Name: %', user_rec.id, user_rec.name;
  END LOOP;
END $$;
</code></pre>

  <h3>更多语法要点</h3>
  <pre><code>-- 声明绑定/未绑定游标
DECLARE
  cur_films  CURSOR FOR SELECT * FROM film;
  cur_films2 CURSOR (year int) FOR SELECT * FROM film WHERE release_year = year;
  my_cursor  REFCURSOR;

-- 打开未绑定/动态 SQL
OPEN my_cursor FOR SELECT * FROM city WHERE country = 'US';
OPEN my_cursor FOR EXECUTE 'SELECT * FROM city ORDER BY ' || quote_ident('name');

-- 打开绑定并传参
OPEN cur_films;
OPEN cur_films2(year := 2005);

-- FETCH 方向示例（需 SCROLL）
FETCH NEXT FROM cur_films INTO ...
FETCH PRIOR FROM cur_films INTO ...
FETCH FIRST FROM cur_films INTO ...
FETCH LAST  FROM cur_films INTO ...
FETCH ABSOLUTE 10 FROM cur_films INTO ...
FETCH RELATIVE -1 FROM cur_films INTO ...

-- 只移动不取行
MOVE LAST FROM cur_films;

-- 基于游标定位更新/删除
UPDATE film SET title = title || ' (X)'
WHERE CURRENT OF cur_films;

DELETE FROM film
WHERE CURRENT OF cur_films;

-- 关闭
CLOSE cur_films;
</code></pre>

  <h3>综合示例：按条件累积字符串</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_film_titles(p_year int)
RETURNS text AS $$
DECLARE
  titles   TEXT DEFAULT '';
  rec_film RECORD;
  cur_films CURSOR(p_year int)
    FOR SELECT title, release_year FROM film WHERE release_year = p_year;
BEGIN
  OPEN cur_films(p_year);
  LOOP
    FETCH cur_films INTO rec_film;
    EXIT WHEN NOT FOUND;
    IF rec_film.title LIKE '%ful%' THEN
      titles := titles || ',' || rec_film.title || ':' || rec_film.release_year;
    END IF;
  END LOOP;
  CLOSE cur_films;
  RETURN titles;
END; $$ LANGUAGE plpgsql;

SELECT get_film_titles(2006);
</code></pre>
</article>

<!-- 54）存储过程（PROCEDURE） -->
<article class="card anchor" id="s54">
  <h2>54）存储过程（PROCEDURE）：语法、事务控制、示例、异常处理</h2>
  <ul>
    <li><b>函数 vs 存储过程</b>：PROCEDURE 不作为表达式返回值（不可在 SELECT 中直接用），可执行事务控制（COMMIT/ROLLBACK）。</li>
    <li>调用方式：<code>CALL procedure_name(...)</code></li>
  </ul>

  <h3>创建语法</h3>
  <pre><code>CREATE [ OR REPLACE ] PROCEDURE procedure_name(
  [ [ IN | OUT | INOUT ] arg_name arg_type [, ...] ]
)
LANGUAGE plpgsql AS $$
BEGIN
  -- 逻辑
END;
$$;
</code></pre>

  <h3>示例：写入并提交</h3>
  <pre><code>CREATE OR REPLACE PROCEDURE sp_add_employee(
  IN emp_name TEXT,
  IN emp_salary NUMERIC
)
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO employees(name, salary)
  VALUES (emp_name, emp_salary);
  COMMIT;  -- 过程内可事务控制
END;
$$;

-- 调用
CALL sp_add_employee('Alice', 10000);
</code></pre>

  <h3>示例：带 OUT 参数</h3>
  <pre><code>CREATE OR REPLACE PROCEDURE sp_get_employee_salary(
  IN emp_id INT,
  OUT salary NUMERIC
)
LANGUAGE plpgsql AS $$
BEGIN
  SELECT emp_salary INTO salary FROM employees WHERE id = emp_id;
END;
$$;

-- 调用：CALL sp_get_employee_salary(1, salary_var);
</code></pre>

  <h3>异常处理</h3>
  <pre><code>CREATE OR REPLACE PROCEDURE sp_example()
LANGUAGE plpgsql AS $$
BEGIN
  -- 可能出错的代码
EXCEPTION
  WHEN others THEN
    RAISE NOTICE '发生错误！';
    -- 可回滚/记录日志等
END;
$$;
</code></pre>

  <p class="meta">注意：存储过程不返回值，若需结果集请用 <code>OUT</code> 参数或让过程内部执行 <code>RAISE NOTICE</code>/写入临时表/客户端 FETCH 等策略；需要表达式返回值请使用 <code>FUNCTION</code>。</p>
</article>
<article class="card anchor" id="s55">
  <h2>55）索引的创建</h2>
  <pre><code>一、语法结构
CREATE [UNIQUE] INDEX index_name
ON table_name
[USING method]
(
    column_name [ASC | DESC] [NULLS {FIRST | LAST}],
    ...
);

-- 参数说明：
-- UNIQUE           ：可选，创建唯一索引，强制列值不重复；
-- index_name       ：索引名称，推荐以 idx_开头；
-- table_name       ：要创建索引的表名；
-- USING method     ：索引方法（如 btree、hash、gin、gist 等），默认是 btree；
-- column_name      ：指定要索引的列名；
-- ASC / DESC       ：可选，指定排序方向，默认 ASC；
-- NULLS FIRST/LAST ：可选，指定 NULL 值排序位置（对 ORDER BY 有影响）；

二、基本示例

-- 示例 1：创建一个普通索引
CREATE INDEX idx_users_email
ON users(email);

-- 示例 2：创建唯一索引（用于防止重复）
CREATE UNIQUE INDEX idx_users_username
ON users(username);

-- 示例 3：为多个列创建联合索引
CREATE INDEX idx_orders_customer_date
ON orders(customer_id, order_date);

-- 示例 4：创建带排序规则和 NULL 排序规则的索引
CREATE INDEX idx_users_created_at
ON users(created_at DESC NULLS LAST);

-- 示例 5：使用指定方法（如 hash）创建索引
CREATE INDEX idx_users_email_hash
ON users USING hash(email);

三、使用建议

-- 适合创建索引的场景：
-- - WHERE 子句中频繁使用的列；
-- - JOIN 中用作连接键的列；
-- - ORDER BY / GROUP BY 中使用的列；
-- - 外键列或需要唯一约束的列；

-- 注意事项：
-- - 创建索引会占用额外的存储空间；
-- - 对频繁更新的表，索引过多可能影响写入性能；
-- - 不建议为小表创建过多索引，可能得不偿失；
-- - 索引名应简洁、具有可读性，一般采用：idx_表名_列名；

-- 索引命名建议：
-- idx_表名_列名，例如：idx_users_email、idx_orders_date

四、创建并发索引（PostgreSQL 12+）

-- 不阻塞写操作的索引创建方式（但不能在事务中执行）：
CREATE INDEX CONCURRENTLY idx_users_last_login
ON users(last_login);

-- 注意：CONCURRENTLY 不能放在 BEGIN ... COMMIT 块中！

五、查看索引信息

-- 查看表上已有的索引：
\d tablename

-- 查看所有索引：
SELECT * FROM pg_indexes WHERE tablename = 'your_table_name';

-- 查看索引大小（按 MB 统计）：
SELECT 
    relname AS index_name,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE relname LIKE 'idx_%';

-- 查看某索引的定义：
SELECT indexdef 
FROM pg_indexes 
WHERE indexname = 'idx_users_email';
</code></pre>
</article>

<article class="card anchor" id="s56">
  <h2>56）删除索引</h2>
  <pre><code>一、标准语法结构
DROP INDEX [CONCURRENTLY]
           [IF EXISTS] index_name
           [CASCADE | RESTRICT];

-- 参数说明：
-- CONCURRENTLY：在不锁表的情况下删除索引，适合生产环境；
-- IF EXISTS    ：避免索引不存在时报错；
-- CASCADE      ：自动删除依赖该索引的对象（如外键/约束）；
-- RESTRICT     ：默认行为，若存在依赖则阻止删除（更安全）；

二、基本示例

-- 示例 1：删除一个索引（常规写法）
DROP INDEX idx_users_email;

-- 示例 2：删除前判断是否存在
DROP INDEX IF EXISTS idx_orders_customer_date;

-- 示例 3：非阻塞方式删除索引（不会锁住表，不能在事务中执行）
DROP INDEX CONCURRENTLY idx_logs_event_time;

-- 示例 4：强制删除索引及其依赖对象
DROP INDEX idx_customers_contact CASCADE;

-- 示例 5：防止误删（默认行为）
DROP INDEX idx_customers_contact RESTRICT;

三、使用 CONCURRENTLY 的注意事项

-- CONCURRENTLY 用于避免锁表，但有以下限制：
-- - 不能在事务块（BEGIN ... COMMIT）中执行；
-- - 删除速度比常规慢；
-- - 删除期间仍允许 DML 操作（如 INSERT / UPDATE / DELETE）；

-- 示例（错误写法，会报错）：
BEGIN;
DROP INDEX CONCURRENTLY idx_users_email;  -- ❌ 不允许
COMMIT;

-- 正确用法（必须独立执行）：
DROP INDEX CONCURRENTLY idx_users_email;

四、查看现有索引

-- 查看表上的索引：
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'your_table_name';

-- 查看索引使用频率：
SELECT 
    relname AS index_name,
    idx_scan AS times_used
FROM pg_stat_user_indexes
WHERE relname = 'idx_users_email';

五、总结建议

-- ✔ 删除前先检查索引是否仍被查询使用；
-- ✔ 删除唯一约束的索引，请使用 ALTER TABLE DROP CONSTRAINT；
-- ✔ 对大表删除索引时建议使用 CONCURRENTLY；
-- ❌ 不建议频繁删除和重建索引，会影响性能与存储；
-- ✔ 删除无效、不常用、重复的索引，可提升写入效率。
</code></pre>
</article>

<article class="card anchor" id="s57">
  <h2>57）PostgreSQL（查看）列出索引的两种方式</h2>
  <pre><code>一、方式一：使用 \d 命令（psql 命令行专用）

-- 命令：
\d table_name

-- 示例：
\d users

-- 说明：
-- - 会列出表的所有字段、索引、约束等信息；
-- - 是 PostgreSQL 自带的元数据查看命令，需在 psql 终端中使用；
-- - 不适用于图形界面工具或其他 SQL 客户端。

-- 输出中索引部分示例：
-- Indexes:
--     "idx_users_email" btree (email)
--     "users_pkey" PRIMARY KEY, btree (id)

二、方式二：查询系统视图 pg_indexes（通用方式）

-- 查询语法（基础版本）：
SELECT
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename = 'your_table_name';

-- 示例：
SELECT
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename = 'users';

-- 查询语法（增强版本：按表名模糊查询 + 排序）：
SELECT
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename LIKE 'c%'     -- 可查找表名以 'c' 开头的所有索引
ORDER BY
    tablename,
    indexname;

-- 输出说明：
-- - tablename ：表名；
-- - indexname ：索引名称；
-- - indexdef  ：索引定义语句；
-- - 可结合 WHERE 过滤 + ORDER BY 排序 提高可读性；

三、补充：查看索引使用情况（可选）

-- 可通过 pg_stat_user_indexes 查看索引是否被使用过：

SELECT
    relname AS index_name,
    idx_scan AS times_used
FROM pg_stat_user_indexes
WHERE relname LIKE 'idx_%';

-- idx_scan = 0 表示该索引尚未被查询使用（可能是冗余索引）。</code></pre>
</article>


<article class="card anchor" id="s58">
  <h2>58）PostgreSQL索引类型</h2>
  <pre><code>一、常见索引类型及说明

| 索引类型 | 说明 |
|----------|------|
| B-tree（默认） | 最常用，支持 =、<、<=、>、>=、BETWEEN 等操作； |
| Hash     | 支持 = 操作，效率高，但不支持范围查询；适合等值查询； |
| GIN（Generalized Inverted Index） | 适用于数组、JSONB、全文搜索字段等； |
| GiST（Generalized Search Tree）   | 适用于空间数据、模糊搜索等场景； |
| SP-GiST | 适合稀疏或层次结构数据，如IP、文本前缀等； |
| BRIN（Block Range Index） | 适合大数据量且列值有顺序特征的表；占用空间小； |

二、创建不同类型索引的语法

-- 1. 默认 B-tree 索引（可以省略 USING btree）
CREATE INDEX idx_users_email ON users(email);

-- 2. Hash 索引
CREATE INDEX idx_users_email_hash ON users USING hash(email);

-- 3. GIN 索引（适合 JSONB 或数组）
CREATE INDEX idx_docs_tags_gin ON documents USING gin(tags);

-- 4. GIN 索引（适合全文搜索）
CREATE INDEX idx_docs_content_gin ON documents USING gin(to_tsvector('english', content));

-- 5. GiST 索引（模糊、空间）
CREATE INDEX idx_shapes_gist ON shapes USING gist(geometry);

-- 6. SP-GiST 索引（适合 trie、稀疏值等）
CREATE INDEX idx_logs_ip_spgist ON logs USING spgist(ip_address);

-- 7. BRIN 索引（大表、顺序列）
CREATE INDEX idx_logs_time_brin ON logs USING brin(event_time);

三、选择索引类型的建议

- 默认使用 B-tree，适合绝大多数常规查询；
- Hash 索引仅适合等值查询，其他操作不支持；
- GIN/GiST 多用于特殊类型字段（数组、JSONB、全文检索）；
- BRIN 适合时间序列、日志等“顺序写入”大表；
- 空间/地理数据建议使用 GiST 索引；

四、查看索引类型

-- 查看表上的索引类型（使用 pg_indexes 和 pg_class）：
SELECT
    idx.indexname,
    am.amname AS index_type
FROM
    pg_indexes idx
JOIN
    pg_class cls ON cls.relname = idx.indexname
JOIN
    pg_index i ON i.indexrelid = cls.oid
JOIN
    pg_am am ON am.oid = cls.relam
WHERE
    idx.tablename = 'your_table_name';

-- 替换 'your_table_name' 为目标表名，例如 'users'；

五、索引类型总结

| 场景 | 推荐索引类型 |
|------|----------------|
| 等值查询             | B-tree / Hash        |
| 范围查询             | B-tree               |
| 数组 / JSONB 查询     | GIN                  |
| 模糊搜索 / 空间查询   | GiST                 |
| 时间序列 / 日志表     | BRIN                 |
| 稀疏层级数据结构      | SP-GiST              |</code></pre>
</article>


<article class="card anchor" id="s59">
  <h2>59）PostgreSQL 唯一索引</h2>
  <pre><code>一、唯一索引简介

- 唯一索引（UNIQUE INDEX）用于保证某列或列组合中的值不重复；
- 可防止插入重复数据；
- PostgreSQL 中主键（PRIMARY KEY）本质上也是一种唯一索引 + 非空约束。

二、创建唯一索引语法

-- 基本语法：
CREATE UNIQUE INDEX index_name
ON table_name (column1 [, column2, ...]);

-- 示例：在 users 表的 email 字段上创建唯一索引
CREATE UNIQUE INDEX idx_users_email_unique
ON users (email);

-- 示例：多个字段联合唯一
CREATE UNIQUE INDEX idx_users_name_birth_unique
ON users (first_name, birth_date);

三、与 UNIQUE 约束的关系

- UNIQUE 约束本质上会隐式创建唯一索引；
- 两者的区别更多体现在语义与用途：
  - **UNIQUE 约束**：用于表结构设计，表示业务规则；
  - **UNIQUE INDEX**：更偏向于性能优化、索引管理层面；

-- 示例（等价于上面）：
ALTER TABLE users ADD CONSTRAINT unique_email UNIQUE (email);

四、删除唯一索引

-- 使用 DROP INDEX：
DROP INDEX IF EXISTS idx_users_email_unique;

-- 注意：不能删除由 UNIQUE 约束自动创建的索引，除非先删除约束：
ALTER TABLE users DROP CONSTRAINT unique_email;

五、唯一索引的注意事项

- 唯一索引会拒绝插入或更新导致重复值的数据；
- 可以创建**部分唯一索引**，仅对满足某条件的行唯一（见下一笔记）；
- 字段中如果允许 NULL，可以插入多个 NULL（PostgreSQL 中 NULL 不等于 NULL）；

六、查询表中有哪些唯一索引

-- 查询当前库中所有唯一索引：
SELECT
    i.relname AS index_name,
    t.relname AS table_name,
    a.attname AS column_name
FROM
    pg_class t,
    pg_class i,
    pg_index ix,
    pg_attribute a
WHERE
    t.oid = ix.indrelid
    AND i.oid = ix.indexrelid
    AND a.attrelid = t.oid
    AND a.attnum = ANY(ix.indkey)
    AND ix.indisunique = true
    AND t.relkind = 'r'  -- 仅限普通表
ORDER BY
    t.relname, i.relname;</code></pre>
</article>
<article class="card anchor" id="s60">
  <h2>60）PostgreSQL 基于表达式的索引</h2>
  <pre><code>一、简介
- 基于表达式的索引（Expression Index）是对某个表达式的结果建立索引，而非直接对列值建立索引；
- 适用于对函数计算结果或复杂表达式进行索引，提高查询效率；
- 例如：对字符串的某种处理结果、计算列、JSON字段的提取结果等。

二、创建语法

CREATE INDEX index_name
ON table_name (expression);

-- expression 可以是任意有效的 SQL 表达式，比如函数调用、算术计算等。

三、示例

-- 示例1：对字符串字段的大小写转换建立索引
CREATE INDEX idx_users_lower_email
ON users (LOWER(email));

-- 查询时需使用相同表达式才能利用索引：
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';

-- 示例2：对计算表达式建立索引，比如对价格取整
CREATE INDEX idx_products_rounded_price
ON products ((ROUND(price)));

-- 查询时使用 ROUND(price) 即可利用该索引：
SELECT * FROM products WHERE ROUND(price) = 100;

-- 示例3：JSON字段的提取表达式索引
CREATE INDEX idx_orders_customer_id
ON orders ((data->>'customer_id'));

-- 查询时需用相同表达式：
SELECT * FROM orders WHERE data->>'customer_id' = '12345';

四、注意事项
- 表达式索引创建后，查询中必须使用与索引表达式完全一致的表达式，才能有效利用索引；
- 支持多列表达式组合索引，如：
  CREATE INDEX idx_example ON table_name ((expression1), (expression2));
- 表达式索引可以是不可变函数，确保索引结果的稳定性；
- 支持与 WHERE 子句结合，创建部分表达式索引（部分索引）；
- 不支持直接使用 ALTER INDEX 修改表达式索引，需删除重建。

五、删除表达式索引

-- 删除表达式索引与普通索引相同：
DROP INDEX IF EXISTS idx_users_lower_email;

六、查看表达式索引信息

-- 查询索引定义（包含表达式）：
SELECT
    indexname,
    indexdef
FROM
    pg_indexes
WHERE
    tablename = 'users'
    AND indexdef LIKE '%LOWER(email)%';</code></pre>
</article>


<article class="card anchor" id="s61">
  <h2>61）PostgreSQL 局部索引（部分索引 Partial Index）</h2>
  <pre><code>一、简介
- 局部索引是只对表中满足特定条件的部分数据建立的索引；
- 适用于数据集中存在明显过滤条件的场景，能节省空间，提高查询效率；
- 例如，只对活跃用户、某状态的数据建立索引。

二、创建语法

CREATE INDEX index_name
ON table_name (column_list)
WHERE condition;

- WHERE 子句限定了索引覆盖的行范围；
- 只有满足 WHERE 条件的行会被索引。

三、示例

-- 示例1：只对活跃用户建立索引
CREATE INDEX idx_users_active_email
ON users (email)
WHERE active = true;

-- 查询示例，只有条件匹配时才用到局部索引
SELECT * FROM users WHERE active = true AND email = 'test@example.com';

-- 示例2：对订单表中未完成状态的数据建立索引
CREATE INDEX idx_orders_pending_customer
ON orders (customer_id)
WHERE status = 'pending';

四、使用注意
- 查询中必须包含索引的 WHERE 条件，才能有效利用局部索引；
- 适合频繁按某条件过滤查询的场景；
- 局部索引减少了索引大小，提高写入性能；
- 结合表达式索引，可以建立更灵活的索引。

五、删除局部索引

DROP INDEX IF EXISTS index_name;

六、查看局部索引信息

-- 查询索引定义，观察 WHERE 条件
SELECT
    indexname,
    indexdef
FROM
    pg_indexes
WHERE
    tablename = 'users'
    AND indexdef LIKE '%WHERE%';</code></pre>
</article>


<article class="card anchor" id="s62">
  <h2>62）PostgreSQL重新索引</h2>
  <pre><code>-- 一、语法
REINDEX [ ( VERBOSE ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } name;

-- 二、说明
-- REINDEX：重建已存在的索引；
-- 会加锁，期间不能读写被影响的索引；

-- 锁类型对比：
-- DROP INDEX：获取读锁和写锁；
-- CREATE INDEX：获取写锁；
-- REINDEX：排外锁（独占锁），影响较大，慎用在高并发场景。

-- 三、示例
REINDEX INDEX idx_users_email;
REINDEX TABLE users;
REINDEX DATABASE mydb;</code></pre>
</article>


<article class="card anchor" id="s63">
  <h2>63）PostgreSQL 在多列上定义索引</h2>
  <pre><code>一、简介
- PostgreSQL 支持在多个列上创建组合索引（也称多列索引）；
- 多列索引可提高多条件查询的效率，常用于联合过滤、排序等场景；
- 注意多列索引的“**最左前缀原则**”对索引使用效果的影响。

二、语法格式

CREATE INDEX index_name
ON table_name (column1, column2, ...);

-- 可指定排序方式和空值处理：
-- column_name [ASC | DESC] [NULLS FIRST | LAST]

三、使用示例

-- 示例1：在 first_name 和 last_name 上创建组合索引
CREATE INDEX idx_users_name
ON users (first_name, last_name);

-- 示例2：指定排序规则
CREATE INDEX idx_users_name_desc
ON users (last_name DESC, first_name ASC);

-- 示例3：带空值排序控制
CREATE INDEX idx_orders_date_status
ON orders (order_date NULLS LAST, status);

四、最左前缀原则（重要）

- 组合索引只有在查询条件中包含“从最左侧开始的连续列”时才会被使用；
- 示例：
  - ✅ 使用索引：`WHERE first_name = 'Tom'`  
  - ✅ 使用索引：`WHERE first_name = 'Tom' AND last_name = 'Lee'`
  - ❌ 不使用索引：`WHERE last_name = 'Lee'`（跳过了最左列）

五、适用场景

- 经常使用多个字段联合查询或排序的表；
- 比如用户搜索、订单列表过滤等；
- 注意字段顺序应根据查询频率和过滤条件设计。

六、查看索引使用情况

-- 查看表上有哪些索引
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'users';

-- 查看实际查询是否使用了索引（EXPLAIN）
EXPLAIN SELECT * FROM users WHERE first_name = 'Tom' AND last_name = 'Lee';</code></pre>
</article>


<article class="card anchor" id="s64">
  <h2>64）PostgreSQL 视图的管理</h2>
  <pre><code>一、什么是视图（View）
- 视图是一个虚拟表，本质是存储的 SELECT 查询；
- 不保存实际数据，每次查询时动态执行；
- 用于简化复杂 SQL、封装逻辑、限制用户访问敏感字段等。

二、创建视图

-- 基本语法：
CREATE [OR REPLACE] VIEW view_name AS
SELECT ...
FROM ...
WHERE ...;

-- 示例：创建一个仅显示活跃用户的视图
CREATE VIEW active_users AS
SELECT id, name, email
FROM users
WHERE is_active = true;

-- 使用 OR REPLACE 更新视图结构
CREATE OR REPLACE VIEW active_users AS
SELECT id, name
FROM users
WHERE is_active = true;

三、带列名创建视图

-- 显式指定视图返回的列名
CREATE VIEW user_emails (user_id, user_email) AS
SELECT id, email FROM users;

四、查询视图数据

-- 与普通表一样
SELECT * FROM active_users;

五、查看视图定义

-- 方法1：在 psql 中使用
\d+ view_name

-- 方法2：查询系统表
SELECT definition
FROM pg_views
WHERE viewname = 'active_users';

六、修改视图名称

-- 修改视图名
ALTER VIEW old_view_name RENAME TO new_view_name;

-- 示例：
ALTER VIEW customer_master RENAME TO customer_info;

七、删除视图

-- 删除视图的语法：
DROP VIEW [IF EXISTS] view_name [CASCADE | RESTRICT];

-- 示例：
DROP VIEW IF EXISTS active_users;

八、可更新视图的限制

- 简单视图可以执行 INSERT、UPDATE、DELETE；
  - 条件：基于单表，无聚合、无 DISTINCT、无 JOIN 等。
- 示例：可更新视图
UPDATE active_users SET name = 'Tom' WHERE id = 1;

- 若视图较复杂，则需借助 INSTEAD OF 触发器实现更新（高级用法）。

九、安全与权限控制

- 可通过视图限制用户访问表的部分字段或部分数据；
- 可对视图设置权限：
  GRANT SELECT ON active_users TO read_only_user;

十、WITH CHECK OPTION（视图插入限制）

-- 语法：
CREATE VIEW view_name AS
SELECT ...
WHERE ...
WITH CHECK OPTION;

-- 作用：确保通过视图插入/更新的数据仍满足视图的 WHERE 条件。

-- 示例：
CREATE VIEW active_users AS
SELECT * FROM users
WHERE is_active = true
WITH CHECK OPTION;

十一、视图 vs 表的对比（简要）

| 项目       | 视图（VIEW）     | 表（TABLE）     |
|------------|------------------|------------------|
| 数据存储   | 不存储数据        | 存储实际数据     |
| 更新能力   | 有条件支持        | 完全支持         |
| 查询性能   | 实时执行          | 高效，依赖索引   |
| 应用场景   | 简化查询、权限控制 | 存储结构化数据   |</code></pre>
</article>


<article class="card anchor" id="s65">
  <h2>65）PostgreSQL 创建可更新的视图</h2>
  <pre><code>一、可更新视图简介
- 默认情况下，**简单视图** 是可更新的；
- 所谓“可更新”是指：可以对视图执行 `INSERT`、`UPDATE`、`DELETE`；
- 若视图基于的查询足够简单，PostgreSQL 能自动将更新操作映射到底层表。

二、满足可更新条件的视图要求
- 视图必须：
  1. 只引用一个表；
  2. 不包含聚合函数（如 SUM、AVG）；
  3. 不包含 `DISTINCT`、`GROUP BY`、`HAVING` 等；
  4. 不包含 `UNION`、`INTERSECT` 等集合操作；
  5. 不包含子查询；
  6. 不使用窗口函数；
  7. 没有 `LIMIT` 或 `OFFSET`；
  8. 所有非空字段必须在视图中可见。

三、创建可更新视图的示例

-- 假设我们有一张员工表：
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    department TEXT NOT NULL,
    salary NUMERIC
);

-- 创建一个视图：只包含 IT 部门员工
CREATE VIEW it_employees AS
SELECT id, name, salary
FROM employees
WHERE department = 'IT';

-- 这个视图是可更新的：
UPDATE it_employees
SET salary = salary + 500
WHERE id = 1;

-- 也支持插入：
INSERT INTO it_employees (name, salary)
VALUES ('Alice', 8000); -- 注意：会自动添加 department = 'IT'

-- 但这样插入会失败（因为 department 字段视图中不可见，无法满足 NOT NULL）：
-- INSERT INTO it_employees (id, name) VALUES (5, 'Bob');

四、WITH CHECK OPTION：控制更新范围

-- 防止用户插入/更新不满足 WHERE 条件的数据
CREATE VIEW it_employees_strict AS
SELECT id, name, salary
FROM employees
WHERE department = 'IT'
WITH CHECK OPTION;

-- 使用 WITH CHECK OPTION 后，这种操作会失败：
UPDATE it_employees_strict
SET department = 'HR'
WHERE id = 1;

-- 插入也必须满足 WHERE 条件，否则拒绝

五、复杂视图不可更新怎么办？

-- 如果视图复杂不可更新（如包含 JOIN），可以使用 INSTEAD OF 触发器（见高级用法）手动实现更新逻辑。

六、总结

| 是否可更新 | 特征说明                                 |
|------------|------------------------------------------|
| ✅ 可更新   | 简单查询、单表、无聚合等                 |
| ❌ 不可更新 | 多表 JOIN、聚合、DISTINCT、GROUP BY 等   |
| ✅ 条件更新 | 可加 WITH CHECK OPTION 限制更新条件       |、</code></pre>
</article>
<article class="card anchor" id="s66">
  <h2>66）PostgreSQL物理化的视图</h2>
  <pre><code>一、物理化视图简介
- 物理化视图（Materialized View）是把查询结果物理存储起来的视图；
- 与普通视图不同，物理化视图的数据是静态的，需要手动刷新才能同步底层表数据；
- 适合查询开销大且不常变的数据缓存，提高查询性能。

二、创建物理化视图

CREATE MATERIALIZED VIEW view_name AS
SELECT ...
[WITH [NO] DATA];

- WITH DATA（默认）表示创建时立即计算并存储数据；
- WITH NO DATA 表示只创建视图结构，不填充数据，数据需后续刷新。

三、刷新物理化视图数据

REFRESH MATERIALIZED VIEW [CONCURRENTLY] view_name;

- 直接刷新会锁住视图，阻塞查询；
- 使用 CONCURRENTLY 可实现并发刷新，查询不受阻塞（需要视图有唯一索引）；

四、删除物理化视图

DROP MATERIALIZED VIEW view_name;

五、示例演示

-- 创建示例表
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    product TEXT,
    amount INT,
    sale_date DATE
);

-- 创建物理化视图，统计每天销售总额
CREATE MATERIALIZED VIEW daily_sales AS
SELECT sale_date, SUM(amount) AS total_amount
FROM sales
GROUP BY sale_date
WITH DATA;

-- 查询视图数据
SELECT * FROM daily_sales;

-- 新增数据后刷新物理化视图
INSERT INTO sales (product, amount, sale_date) VALUES ('A', 10, '2025-09-16');
REFRESH MATERIALIZED VIEW daily_sales;

-- 并发刷新（不阻塞查询，视图需有唯一索引）
CREATE UNIQUE INDEX daily_sales_date_idx ON daily_sales(sale_date);
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales;

-- 删除物理化视图
DROP MATERIALIZED VIEW daily_sales;

六、总结

| 特点                 | 说明                                  |
|----------------------|-------------------------------------|
| 数据存储              | 查询结果物理存储，提高查询速度         |
| 数据更新              | 需要手动刷新，数据非实时                |
| 创建选项              | 可选择 WITH DATA 或 WITH NO DATA       |
| 并发刷新              | 支持 CONCURRENTLY 选项，避免锁表        |
| 使用场景              | 大量复杂查询，数据更新不频繁的场景      |</code></pre>
</article>


<article class="card anchor" id="s67">
  <h2>67）PostgreSQL 创建可更新视图使用 CHECK 选项</h2>
  <pre><code>一、背景介绍
- 默认情况下，简单视图是可更新的；
- 但视图中的 WHERE 条件可能会导致插入或更新时数据不符合条件，影响数据完整性；
- PostgreSQL 提供 `WITH CHECK OPTION` 来保证插入或更新的数据满足视图的条件。

二、WITH CHECK OPTION 作用
- 约束用户通过视图插入或更新的数据必须满足视图定义中的 WHERE 条件；
- 防止不符合条件的数据被写入底层表，保证视图数据的一致性和有效性。

三、使用方法

CREATE VIEW view_name AS
SELECT ...
FROM table_name
WHERE 条件
WITH CHECK OPTION;

- `WITH CHECK OPTION` 放在视图定义的最后；
- 插入或更新不满足 WHERE 条件的数据会报错，操作失败。

四、示例演示

-- 创建基础表
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    department TEXT NOT NULL,
    salary NUMERIC
);

-- 创建一个只包含 IT 部门员工的视图，带 CHECK OPTION
CREATE VIEW it_employees AS
SELECT id, name, salary
FROM employees
WHERE department = 'IT'
WITH CHECK OPTION;

-- 通过视图插入符合条件的数据，成功
INSERT INTO it_employees (name, salary)
VALUES ('Alice', 8000);

-- 通过视图插入不符合条件的数据，失败
-- INSERT INTO it_employees (name, salary) VALUES ('Bob', 7000);
-- 报错：违反 WITH CHECK OPTION 约束，因为 department='IT' 条件不满足

-- 通过视图更新操作，也必须满足条件
UPDATE it_employees
SET salary = salary + 500
WHERE id = 1;

-- 更新为不满足条件，会失败
-- UPDATE it_employees
-- SET department = 'HR'
-- WHERE id = 1;

五、小结

| 特性              | 说明                                      |
|-------------------|-----------------------------------------|
| 数据完整性保障    | 保障视图上的插入/更新符合 WHERE 条件      |
| 操作限制          | 插入或更新不满足条件的数据操作会失败       |
| 适用场景          | 需要保证视图中数据符合特定业务规则的情况    |</code></pre>
</article>


<article class="card anchor" id="s68">
  <h2>68）PostgreSQL 触发器介绍</h2>
  <pre><code>一、触发器简介
- 触发器（Trigger）是数据库对象，在特定事件发生时自动执行预定义的函数；
- 常用于实现自动化业务逻辑、数据校验、审计日志等；
- 触发器可以在表的 `INSERT`、`UPDATE`、`DELETE` 操作前或后触发。

二、触发器的组成
1. 触发事件（Trigger Event）：INSERT、UPDATE、DELETE；
2. 触发时机（Trigger Timing）：BEFORE（之前）、AFTER（之后）、INSTEAD OF（视图触发器）；
3. 触发函数（Trigger Function）：用 PL/pgSQL 或其他语言编写，执行具体操作。

三、触发器的作用场景
- 自动维护统计数据或派生数据；
- 实现复杂的业务规则和校验；
- 审计用户操作，记录变更历史；
- 维护数据完整性，补充约束逻辑；
- 支持视图的可更新操作（INSTEAD OF 触发器）。

四、触发器分类

| 触发时机        | 说明                             |
|-----------------|----------------------------------|
| BEFORE          | 在操作执行前触发，能修改数据     |
| AFTER           | 在操作执行后触发，通常用于日志等 |
| INSTEAD OF      | 视图专用，替代操作执行           |

五、注意事项
- 触发器执行后不能直接返回 NULL（BEFORE 触发器必须返回 NEW 或 OLD）；
- 触发器执行影响性能，慎用；
- 复杂业务尽量写在触发函数内，保持触发器简洁。

六、小结

| 关键点       | 说明                                  |
|--------------|---------------------------------------|
| 触发时机     | BEFORE、AFTER、INSTEAD OF             |
| 触发事件     | INSERT、UPDATE、DELETE                 |
| 触发函数     | 用 PL/pgSQL 编写，执行具体逻辑         |
| 应用场景     | 数据校验、审计、自动更新、视图更新支持 |</code></pre>
</article>


<article class="card anchor" id="s69">
  <h2>69）PostgreSQL 触发器的创建</h2>
  <pre><code>/*
一、触发器简介
- 触发器是数据库对象，能在特定事件发生时自动执行预定义的函数。
- 事件包括：INSERT、UPDATE、DELETE。
- 用于自动化任务、数据验证、审计等。

二、触发器函数（Trigger Function）
- 必须是无参数、返回触发器类型的函数。
- 通常用 PL/pgSQL 编写。

示例：
CREATE OR REPLACE FUNCTION trigger_function_name()
RETURNS TRIGGER AS $$
BEGIN
    -- 触发器逻辑
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

三、创建触发器语法

CREATE TRIGGER trigger_name
    { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }
    ON table_name
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    EXECUTE PROCEDURE trigger_function();

说明：
- trigger_name：触发器名称。
- BEFORE / AFTER / INSTEAD OF：触发器时机。
- event：事件类型，如 INSERT、UPDATE、DELETE。
- table_name：绑定的表或视图。
- FOR EACH ROW：对每行执行一次。
- FOR EACH STATEMENT：对整个语句执行一次。

四、示例

-- 创建一个触发器函数，更新某列时间戳
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建 BEFORE UPDATE 触发器
CREATE TRIGGER set_timestamp
BEFORE UPDATE ON employees
FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();

五、小结
- 触发器函数定义触发器执行的操作。
- CREATE TRIGGER 绑定触发器到表及事件。
- 触发器可以在不同时间点响应多种事件。
*/</code></pre>
</article>


<article class="card anchor" id="s70">
  <h2>70）PostgreSQL 触发器的删除</h2>
  <pre><code>/*
一、DROP TRIGGER 简介
- 用于删除已定义的触发器。
- 必须指定触发器所在的表。

二、基本语法

DROP TRIGGER [IF EXISTS] trigger_name ON table_name [CASCADE | RESTRICT];

参数说明：
- trigger_name：要删除的触发器名称。
- table_name：触发器所在的表名。
- IF EXISTS：如果触发器不存在则不报错。
- CASCADE：自动删除依赖该触发器的对象。
- RESTRICT：如果有依赖项，则拒绝删除（默认）。

三、示例

-- 删除名为 set_timestamp 的触发器
DROP TRIGGER set_timestamp ON employees;

-- 如果存在才删除
DROP TRIGGER IF EXISTS set_timestamp ON employees;

-- 强制级联删除依赖对象（如有）
DROP TRIGGER set_timestamp ON employees CASCADE;

四、注意事项
- 不能直接删除触发器函数（要使用 DROP FUNCTION）。
- 删除触发器不会影响原始表结构或数据。
*/</code></pre>
</article>


<article class="card anchor" id="s71">
  <h2>71）PostgreSQL 触发器的管理</h2>
  <pre><code>/*
一、重命名触发器（修改名称）

语法：
ALTER TRIGGER old_name ON table_name RENAME TO new_name;

示例：
-- 将触发器名 set_timestamp 改为 update_timestamp
ALTER TRIGGER set_timestamp ON employees RENAME TO update_timestamp;


二、禁用触发器

语法：
-- 禁用单个触发器：
ALTER TABLE table_name DISABLE TRIGGER trigger_name;

-- 禁用所有触发器（包括系统触发器）：
ALTER TABLE table_name DISABLE TRIGGER ALL;

示例：
-- 禁用某个特定触发器
ALTER TABLE employees DISABLE TRIGGER update_timestamp;

-- 禁用所有触发器
ALTER TABLE employees DISABLE TRIGGER ALL;


三、启用触发器

语法：
-- 启用单个触发器：
ALTER TABLE table_name ENABLE TRIGGER trigger_name;

-- 启用所有触发器：
ALTER TABLE table_name ENABLE TRIGGER ALL;

示例：
-- 启用某个触发器
ALTER TABLE employees ENABLE TRIGGER update_timestamp;

-- 启用所有触发器
ALTER TABLE employees ENABLE TRIGGER ALL;

四、注意事项：
- 禁用触发器后，相关的 INSERT / UPDATE / DELETE 操作将不会触发。
- 禁用或启用触发器，必须具有对表的 ALTER 权限。
- 触发器函数本身不会被删除或修改，只影响触发器行为。
*/</code></pre>
</article>


<article class="card anchor" id="s72">
  <h2>72）PostgreSQL 角色管理</h2>
  <pre><code>/*
一、什么是角色（Role）

- PostgreSQL 用“角色”统一管理用户和权限；
- 每个连接数据库的用户其实就是一个“可登录的角色”；
- 角色分为：
  1. 可登录角色（LOGIN）：可以连接数据库；
  2. 不可登录角色：用于作为权限集合（类似权限组）；
- 角色之间可以通过继承实现权限共享。

二、创建角色

1. 创建可登录的用户角色：
CREATE ROLE role_name WITH LOGIN PASSWORD 'password';

示例：
CREATE ROLE alice WITH LOGIN PASSWORD 'alice123';

2. 创建不可登录的权限组角色：
CREATE ROLE readonly;

3. 创建带继承权限的角色（默认）：
CREATE ROLE dev_user WITH LOGIN INHERIT PASSWORD 'dev123';

4. 创建不继承的角色：
CREATE ROLE isolated_user WITH LOGIN NOINHERIT PASSWORD 'iso123';

三、角色继承（INHERIT / NOINHERIT）

- PostgreSQL 中，角色可以“继承”被授予的角色的权限。
- 使用 `GRANT` 将 role_b 授权给 role_a 后，是否**自动拥有权限**，取决于 `INHERIT` 设置：

| 设置        | 效果说明                                               |
|-------------|--------------------------------------------------------|
| INHERIT     | 默认设置，自动拥有被授予角色的权限（无需 SET ROLE）   |
| NOINHERIT   | 不自动继承，被授予角色的权限，需手动 SET ROLE 使用    |

示例：

-- 创建两个角色
CREATE ROLE readonly;
CREATE ROLE alice WITH LOGIN INHERIT PASSWORD '123456';

-- 授权 readonly 给 alice
GRANT readonly TO alice;

-- alice 自动继承 readonly 的权限（因为有 INHERIT）

-- 如果 alice 是 NOINHERIT，则需要显式：
SET ROLE readonly;

-- 恢复当前角色：
RESET ROLE;

四、授予权限

-- 授予数据库连接权限：
GRANT CONNECT ON DATABASE dbname TO role_name;

-- 授权对表的操作：
GRANT SELECT, INSERT ON table_name TO role_name;

-- 授权继承其他角色权限：
GRANT role_b TO role_a;

-- 授权所有表的权限（批量）：
GRANT SELECT ON ALL TABLES IN SCHEMA public TO role_name;

五、修改角色属性

-- 修改密码：
ALTER ROLE alice WITH PASSWORD 'newpass';

-- 允许创建数据库：
ALTER ROLE alice WITH CREATEDB;

-- 修改继承设置：
ALTER ROLE alice WITH NOINHERIT;
ALTER ROLE alice WITH INHERIT;

-- 修改角色名：
ALTER ROLE alice RENAME TO alice_dev;

六、删除角色

-- 删除角色：
DROP ROLE readonly;

-- 防止报错（角色不存在时）：
DROP ROLE IF EXISTS readonly;

-- 若角色已拥有对象，应先处理：
-- 重新分配对象：
REASSIGN OWNED BY old_role TO new_role;

-- 丢弃拥有的所有对象：
DROP OWNED BY old_role;

七、查看角色和权限

-- 查看所有角色：
\du      -- psql 中使用

-- 查询角色属性：
SELECT rolname, rolsuper, rolcreaterole, rolcreatedb, rolcanlogin, rolinherit
FROM pg_roles;

-- 当前用户：
SELECT current_user;

-- 查看权限：
SELECT * FROM information_schema.role_table_grants
WHERE grantee = 'alice';

八、常见角色属性汇总

| 属性         | 说明                                               |
|--------------|----------------------------------------------------|
| LOGIN        | 能否登录数据库                                     |
| SUPERUSER    | 是否为超级用户（拥有所有权限）                    |
| CREATEDB     | 是否可以创建数据库                                 |
| CREATEROLE   | 是否可以创建/删除其他角色                          |
| INHERIT      | 是否自动继承授予的其他角色的权限（默认开启）       |
| NOINHERIT    | 需显式 SET ROLE 才能使用被授予角色的权限           |
| REPLICATION  | 是否具有流复制权限                                 |
| BYPASSRLS    | 是否可以绕过行级安全策略（RLS）                    |

九、总结

- 使用 `CREATE ROLE` 定义用户/权限组；
- `INHERIT` 控制是否自动继承其他角色权限；
- `GRANT` 用于分配权限或角色；
- `ALTER ROLE` 可修改角色属性；
- `DROP ROLE` 删除角色，需先处理依赖。
*/</code></pre>
</article>

<article class="card anchor" id="s73">
  <h2>73）PostgreSQL 数据库的备份</h2>
  <pre><code>一、备份方式分类

PostgreSQL 提供多种备份方式，主要分为：

1. SQL文本备份（逻辑备份）：
   - 使用 `pg_dump` 工具；
   - 导出为 SQL 文件；
   - 适合结构和数据的迁移或版本控制；
   - 可选择备份整个数据库或部分表。

2. 自定义归档格式备份（压缩）：
   - 使用 `pg_dump -Fc`；
   - 可用于 `pg_restore` 还原；
   - 支持并行还原。

3. 目录格式备份（适合并行恢复）：
   - 使用 `pg_dump -Fd`；
   - 输出为一个目录，适合大数据量。

4. 文件系统级别备份（物理备份）：
   - 使用 `pg_basebackup` 或直接复制数据目录；
   - 适合数据库级别完整还原；
   - 需搭配归档日志 (WAL)。

---

二、pg_dump 命令使用

1. 备份整个数据库（文本格式）：
pg_dump -U username -d dbname -f backup.sql

2. 备份整个数据库（自定义格式）：
pg_dump -U username -F c -f backup.dump dbname

3. 备份指定表：
pg_dump -U username -d dbname -t table_name -f table_backup.sql

4. 压缩备份输出：
pg_dump -U username -d dbname | gzip > backup.sql.gz

5. 指定 schema 备份：
pg_dump -U username -n schema_name -f schema_backup.sql dbname

6. 使用目录格式备份（并行支持）：
pg_dump -U username -Fd -j 4 -f /path/to/backup_dir dbname

参数说明：
- `-U`：指定用户名；
- `-d`：目标数据库；
- `-F`：备份格式（p=plain, c=custom, d=directory）；
- `-f`：输出文件名；
- `-j`：并行度（配合 `-Fd` 使用）；

---

三、pg_basebackup：物理备份工具

适合做流复制或完整的物理备份。

基本用法：
pg_basebackup -U repl_user -D /path/to/backup -Fp -Xs -P

说明：
- `-D`：指定输出目录；
- `-Fp`：使用普通文件格式（也可 -Ft 为 tar）；
- `-Xs`：包含 WAL 日志；
- `-P`：显示进度。

注意：
- 需开启 `wal_level = replica`；
- 需配置 `pg_hba.conf` 允许 `replication` 用户访问；
- 通常配合流复制使用。

---

四、备份注意事项

- **定期备份**：生产环境建议至少每日备份；
- **备份验证**：定期使用 `pg_restore` 或 `psql` 测试还原；
- **避免高峰期**：备份期间数据库可能变慢；
- **权限控制**：备份用户必须具备读取数据库所有对象的权限；
- **安全存储**：备份文件应加密并异地保存。

---

五、常见问题

| 问题                        | 说明                                      |
|-----------------------------|-------------------------------------------|
| pg_dump 无法连接数据库     | 检查用户名、密码、网络、端口              |
| 权限不足                   | 使用超级用户或具备读取权限的角色          |
| pg_basebackup 报错权限     | 检查 `pg_hba.conf` 中是否授权 replication |
| 备份文件太大               | 使用压缩（gzip 或 `pg_dump -Fc`）         |

---

六、总结

| 工具         | 类型       | 用途                       |
|--------------|------------|----------------------------|
| pg_dump      | 逻辑备份   | 导出为 SQL 或自定义格式    |
| pg_restore   | 逻辑恢复   | 用于还原自定义格式         |
| pg_basebackup| 物理备份   | 用于全量热备或流复制初始化 |

-- 建议配合计划任务（cron）自动备份，并加上时间戳区分备份文件。</code></pre>
</article>


<article class="card anchor" id="s74">
  <h2>74）PostgreSQL 数据库的还原</h2>
  <pre><code>一、【还原方式分类】

-- PostgreSQL 的还原方式取决于备份格式。不同方式支持的功能如下：

1. SQL 脚本（使用 psql 工具）
   - ✅ 支持还原结构 + 数据
   - ❌ 不支持并行
   - ✅ 支持部分还原（需手动编辑 SQL 文件）

2. 自定义格式（.dump 文件，使用 pg_restore）
   - ✅ 支持还原结构 + 数据
   - ✅ 支持并行还原（使用 -j 选项）
   - ✅ 支持选择性还原（通过参数如 -t、-n 等）

3. 目录格式（使用 -Fd 生成，使用 pg_restore）
   - ✅ 支持还原结构 + 数据
   - ✅ 支持并行还原
   - ✅ 支持选择性还原

4. 物理备份（拷贝数据目录或使用 pg_basebackup）
   - ✅ 支持完整还原（整个数据库实例）
   - ❌ 不支持并行
   - ❌ 不支持部分还原（必须恢复整个实例）

-- 建议：
-- - 日常备份使用 SQL 脚本或自定义格式；
-- - 对大型数据库，推荐使用目录格式配合并行还原；
-- - 灾难恢复场景，使用物理备份更合适。

二、使用 SQL 脚本还原（psql 工具）

适用于 `pg_dump` 导出的 `.sql` 文件。

基本语法：
psql -U username -d target_db -f backup.sql

示例：
psql -U postgres -d mydb -f backup.sql

说明：
- `-U`：指定连接用户；
- `-d`：目标数据库（需已存在）；
- `-f`：SQL 脚本备份路径；
- 使用前需手动创建数据库。

------------------------------------------------------------

三、使用 pg_restore 还原自定义格式或目录格式

适用于 `.dump` 文件或目录格式（-Fd）。

基本语法：
pg_restore -U username -d target_db backup.dump

示例（自定义格式）：
pg_restore -U postgres -d mydb backup.dump

示例（目录格式 + 并行）：
pg_restore -U postgres -d mydb -Fd backup_dir -j 4

如果想让 pg_restore 创建数据库，可以配合 -C 使用（需要连接到 template1）：
pg_restore -U postgres -C -d template1 backup.dump

------------------------------------------------------------

四、pg_restore 常用参数说明

| 参数                | 含义                                 |
|---------------------|--------------------------------------|
| -C                  | 创建数据库（配合 -d template1）     |
| -c                  | 还原前先清除原有对象（DROP）        |
| -j [n]              | 并行线程数（只适用于目录格式）      |
| -t table_name       | 只恢复指定表                         |
| -n schema_name      | 只恢复指定 schema                    |
| --list              | 查看备份文件内容（可用于过滤恢复）  |
| --schema-only       | 仅还原结构                           |
| --data-only         | 仅还原数据                           |

示例：只恢复某个表
pg_restore -U postgres -d mydb -t customers backup.dump

示例：只还原结构
pg_restore -U postgres -d mydb --schema-only backup.dump

------------------------------------------------------------

五、物理备份还原（data 目录）

适用于 pg_basebackup 或拷贝整个 data 目录的物理备份。

还原步骤：
1. 停止 PostgreSQL 服务；
2. 将 data 目录替换为备份目录；
3. 确保权限设置正确（postgres 用户拥有）；
4. 恢复配置文件（如 postgresql.conf、pg_hba.conf）；
5. 启动 PostgreSQL 服务。

说明：
- 若包含 WAL 日志（归档模式），需配合 restore_command 恢复；
- 适合灾难恢复、热备或主从同步初始化；
- 不支持部分还原，整个实例级别。

------------------------------------------------------------

六、还原注意事项

- 恢复 SQL 脚本时数据库需已存在（除非脚本中包含 CREATE DATABASE）；
- 使用 pg_restore + -C 可自动创建数据库；
- 恢复后建议执行 `ANALYZE` 或 `VACUUM ANALYZE` 优化查询性能；
- 恢复后检查权限、扩展、依赖是否齐全；
- 若有外键依赖，可加 `--disable-triggers` 临时关闭触发器。

------------------------------------------------------------

七、常见问题处理

1. 错误：关系已存在
   → 加 `-c` 参数清空原有对象再还原。

2. 报错权限不足
   → 确保使用超级用户或有足够权限的角色。

3. 中文乱码
   → 创建数据库时需指定编码，例如：UTF8。

4. pg_restore 无法识别 SQL 文件
   → pg_restore 仅支持 `.dump` / 目录格式，SQL 文件需用 psql 还原。

------------------------------------------------------------

八、总结

| 工具       | 适用格式       | 特点                             |
|------------|----------------|----------------------------------|
| psql       | SQL 脚本       | 简单易用，结构清晰               |
| pg_restore | .dump/目录格式 | 支持并行、选择性还原             |
| 物理恢复   | data 目录      | 快速完整，但粗粒度，难以过滤     |

-- 最佳实践：中小型数据库使用 SQL 备份；大型数据库推荐自定义格式 + pg_restore。</code></pre>
</article>


<article class="card anchor" id="s75">
  <h2>75）PostgreSQL 表空间创建</h2>
  <pre><code>一、表空间简介
- 表空间（Tablespace）用于指定数据库对象（表、索引等）在物理存储上的位置。
- 通过表空间，可以将数据分散到不同的磁盘，提高性能和管理灵活性。

二、创建表空间的要求
- 操作系统上必须存在目标目录，且 PostgreSQL 服务器进程拥有该目录的读写权限。
- 目录必须为空，且不能是 PostgreSQL 数据目录的一部分。

三、创建表空间的语法

CREATE TABLESPACE tablespace_name
LOCATION 'directory_path';

- tablespace_name：自定义表空间名；
- directory_path：操作系统上的绝对路径，必须是服务器能访问的路径。

四、示例

-- 创建一个表空间，存储路径为 /var/lib/postgresql/tablespaces/fastspace
CREATE TABLESPACE fastspace
LOCATION '/var/lib/postgresql/tablespaces/fastspace';

五、使用表空间

-- 创建表时指定表空间
CREATE TABLE my_table (
    id SERIAL PRIMARY KEY,
    data TEXT
) TABLESPACE fastspace;

-- 创建索引时指定表空间
CREATE INDEX my_index ON my_table(data) TABLESPACE fastspace;

六、查看现有表空间

-- 查看所有表空间信息
SELECT spcname, pg_tablespace_location(oid) AS location FROM pg_tablespace;

七、注意事项
- 删除表空间前，必须先删除所有依赖该表空间的对象；
- 删除表空间命令：DROP TABLESPACE tablespace_name;
- 表空间只管理物理存储，不影响逻辑数据库结构。

八、小结

| 作用         | 说明                            |
|--------------|--------------------------------|
| 优化存储     | 将数据库对象放置于不同磁盘/路径  |
| 提升性能     | 分散 I/O，减轻单一磁盘压力      |
| 管理灵活性   | 便于存储规划和空间管理           |</code></pre>
</article>


<article class="card anchor" id="s76">
  <h2>76）表空间修改和删除</h2>
  <pre><code>一、修改表空间
-- 语法
ALTER TABLESPACE tablespace_name
    RENAME TO new_tablespace_name;

ALTER TABLESPACE tablespace_name
    OWNER TO new_owner;

-- 示例：修改表空间名称
ALTER TABLESPACE myspace RENAME TO myspace_new;

-- 示例：修改表空间所有者
ALTER TABLESPACE myspace OWNER TO postgres;

二、删除表空间
-- 语法
DROP TABLESPACE [IF EXISTS] tablespace_name;

-- 示例：删除一个表空间
DROP TABLESPACE myspace;

-- 示例：安全删除（不存在时不报错）
DROP TABLESPACE IF EXISTS myspace;

三、注意事项
-- - 删除表空间前需确保没有数据库对象存放其中；
-- - 若有依赖对象需转移或删除，否则 DROP 会失败；
-- - 修改表空间不会移动已存储的数据文件；
-- - 表空间的物理目录不会自动删除，需手动清理。
</code></pre>
</article>

    </section>
  </div>
</body>
</html>
