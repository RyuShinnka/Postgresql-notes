
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PostgreSQL 学习笔记（全量合并版）</title>
<style>
:root{
  --bg: linear-gradient(135deg, #f9fafb, #e5ebf2);
  --card:#ffffff;
  --border:#cbd5e1;
  --text:#111827;
  --muted:#374151;
  --accent:#2563eb;
  --green:#16a34a;
  --orange:#ea580c;
  --red:#dc2626;
  --code:#f3f4f6;
}

  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
    font:16px/1.65 "Inter","Noto Sans SC","Noto Sans CJK SC","Segoe UI",system-ui,-apple-system,sans-serif;}
  a{color:var(--accent);text-decoration:none}
  a:hover{text-decoration:underline}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  header{margin-bottom:24px}
  h1{font-size:28px;letter-spacing:.3px;margin:0 0 8px 0}
  .meta{color:var(--muted);font-size:14px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
  .card{grid-column:1/-1;background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px}
  h2{font-size:22px;margin:4px 0 12px 0}
  h3{font-size:18px;margin:18px 0 8px 0}
  p{margin:8px 0}
  ul{margin:6px 0 12px 18px}
  code,kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", monospace}
  pre{background:var(--code);border:1px solid var(--border);border-radius:12px;padding:12px;overflow:auto}
  .tag{display:inline-block;border:1px solid var(--border);padding:2px 8px;border-radius:999px;color:var(--muted);font-size:12px;margin-right:8px}
  .ok{color:var(--green)} .warn{color:var(--orange)} .bad{color:var(--red)}
  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width: 760px){ .two-col{grid-template-columns:1fr;} }
  nav.toc{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:16px}
  nav.toc ol{margin:0 0 0 18px}
  nav.toc a{font-size:14px}
  .anchor{scroll-margin-top:80px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>PostgreSQL 学习笔记</h1>
    </header>

    <nav class="toc card">
      <strong>目录</strong>
      <ol>
        <li><a href="#s1">SQL 执行顺序（通用）</a></li>
        <li><a href="#s2">字符串 / 正则（含 REGEXP 等价写法）</a></li>
        <li><a href="#s3">日期时间与间隔：EXTRACT / INTERVAL / 时间差</a></li>
        <li><a href="#s4">TRUNCATE / ALTER TABLE（PostgreSQL 写法）</a></li>
        <li><a href="#s5">窗口函数与窗口帧</a></li>
        <li><a href="#s6">JOIN 全家桶</a></li>
        <li><a href="#s7">LIKE / ILIKE 与操作符</a></li>
        <li><a href="#s8">集合操作：UNION / INTERSECT / EXCEPT</a></li>
        <li><a href="#s9">GROUPING SETS / CUBE / ROLLUP</a></li>
        <li><a href="#s10">子查询：ANY / ALL / EXISTS / NOT EXISTS</a></li>
        <li><a href="#s11">CTE 与递归 CTE</a></li>
        <li><a href="#s12">DML：INSERT...SELECT / UPDATE...FROM / UPSERT</a></li>
        <li><a href="#s13">事务</a></li>
        <li><a href="#s14">创建数据库与对象大小</a></li>
        <li><a href="#s15">创建表、列/表级约束（PK/FK/UNIQUE/CHECK/NOT NULL）</a></li>
        <li><a href="#s16">SELECT INTO / CREATE TABLE AS</a></li>
        <li><a href="#s17">自增：SERIAL / SEQUENCE / IDENTITY（含管理）</a></li>
        <li><a href="#s18">ALTER TABLE / DROP TABLE</a></li>
        <li><a href="#s19">案例：按日统计售卖率（PostgreSQL 版）</a></li>
        <li><a href="#s20">DISTINCT ON（每组取一行）</a></li>
        <li><a href="#s21">分页：LIMIT/OFFSET 与锚点翻页</a></li>
        <li><a href="#s22">BOOLEAN（布尔类型）</a></li>
        <li><a href="#s23">字符数据类型</a></li>
        <li><a href="#s24">数值类型总览与函数</a></li>
        <li><a href="#s25">整数类型与 SERIAL（强化）</a></li>
        <li><a href="#s26">日期与时间数据类型（总览）</a></li>
        <li><a href="#s27">TIMESTAMP vs TIMESTAMPTZ</a></li>
        <li><a href="#s28">INTERVAL（时间间隔）</a></li>
        <li><a href="#s29">UUID</a></li>
        <li><a href="#s30">数组类型</a></li>
        <li><a href="#s31">JSON / JSONB</a></li>
        <li><a href="#s32">从 JSON 提取数值并聚合</a></li>
        <li><a href="#s33">Schema 管理</a></li>
        <li><a href="#s34">COALESCE</a></li>
        <li><a href="#s35">NULLIF</a></li>
        <li><a href="#s36">CAST / ::</a></li>
        <li><a href="#s37">CASE 表达式</a></li>
        <li><a href="#s38">删除重复数据（DELETE USING）</a></li>
        <li><a href="#s39">RANDOM()</a></li>
        <li><a href="#s40">EXPLAIN</a></li>
        <li><a href="#s41">PostgreSQL vs MySQL 对比</a></li>
        <li><a href="#s42">EXCEPT 补充</a></li>
        <li><a href="#s43">PL/pgSQL：块结构</a></li>
        <li><a href="#s44">PL/pgSQL：变量</a></li>
        <li><a href="#s45">PL/pgSQL：常量</a></li>
        <li><a href="#s46">创建函数与存储过程</a></li>
        <li><a href="#s47">函数参数四种模式</a></li>
        <li><a href="#s48">函数重载</a></li>
        <li><a href="#s49">使用函数返回一张表（RETURNS TABLE / RETURN QUERY / RETURN NEXT）</a></li>
        <li><a href="#s50">IF 判断语句</a></li>
        <li><a href="#s51">CASE 判断语句（简单 / 可搜索）</a></li>
        <li><a href="#s52">循环：LOOP / WHILE / FOR（含 EXIT / CONTINUE）</a></li>
        <li><a href="#s53">游标 Cursor：显式/隐式、FETCH/MOVE、CURRENT OF、示例</a></li>
        <li><a href="#s54">存储过程（PROCEDURE）：语法、事务控制、示例、异常处理</a></li>
        <li><a href="#s55">索引的创建</a></li>
        <li><a href="#s56">删除索引</a></li>
        <li><a href="#s57">查看索引的方式</a></li>
        <li><a href="#s58">索引类型</a></li>
        <li><a href="#s59">唯一索引</a></li>
        <li><a href="#s60">基于表达式的索引</a></li>
        <li><a href="#s61">局部索引（部分索引）</a></li>
        <li><a href="#s62">重新索引（REINDEX）</a></li>
        <li><a href="#s63">多列索引</a></li>
        <li><a href="#s64">视图管理</a></li>
        <li><a href="#s65">可更新视图</a></li>
        <li><a href="#s66">物理化视图</a></li>
        <li><a href="#s67">视图的 WITH CHECK OPTION</a></li>
        <li><a href="#s68">触发器介绍</a></li>
        <li><a href="#s69">触发器的创建</a></li>
        <li><a href="#s70">触发器的删除</a></li>
        <li><a href="#s71">触发器的管理</a></li>
        <li><a href="#s72">角色管理</a></li>
        <li><a href="#s73">数据库的备份</a></li>
        <li><a href="#s74">数据库的还原</a></li>
        <li><a href="#s75">表空间创建</a></li>
        <li><a href="#s76">表空间修改和删除</a></li>

      </ol>
    </nav>

    <section class="grid">

      <article class="card anchor" id="s1">
        <h2>1）SQL 执行顺序（通用，适用于 PostgreSQL）</h2>
        <p><span class="tag">FROM/ON</span> → <span class="tag">WHERE</span> → <span class="tag">GROUP BY</span> → <span class="tag">HAVING</span> → <span class="tag">SELECT（窗口函数在此阶段）</span> → <span class="tag">ORDER BY</span></p>
      </article>

      <article class="card anchor" id="s2">
        <h2>2）字符串 / 正则（替代 MySQL REGEXP_SUBSTR）</h2>
        <ul>
          <li><b>字符串拼接：</b> <code>expr1 || expr2</code></li>
          <li><b>长度：</b> <code>char_length(text)</code>（字符数），<code>octet_length(text)</code>（字节数）；<code>length(text)</code> 等价于 <code>char_length</code></li>
        </ul>
        <pre><code>-- 取第一个匹配子串（等价 REGEXP_SUBSTR 的基本场景）
SELECT substring('abc-123-def' FROM '\d+');  -- → '123'

-- 全部匹配（返回 setof text）
SELECT regexp_matches('a1b22c333', '\d+', 'g');  -- 多行返回 1,22,333

-- 是否匹配
SELECT 'foo@example.com' ~ '^[^@]+@[^@]+$';  -- true/false
</code></pre>
      </article>

      <article class="card anchor" id="s3">
        <h2>3）日期时间与间隔：EXTRACT / INTERVAL / 时间差</h2>
        <div class="two-col">
          <div>
            <h3>时间差（替代 MySQL TIMESTAMPDIFF）</h3>
            <pre><code>-- 两个时间相减得到 interval
SELECT end_ts - start_ts AS diff;

-- 转分钟数
SELECT EXTRACT(EPOCH FROM (end_ts - start_ts)) / 60 AS minutes;
</code></pre>
          </div>
          <div>
            <h3>日期加减（替代 DATE_ADD / DATE_SUB）</h3>
            <pre><code>SELECT ts + INTERVAL '3 days';
SELECT ts - INTERVAL '2 hours';
SELECT CURRENT_DATE + INTERVAL '1 month';
</code></pre>
          </div>
        </div>
        <h3>EXTRACT</h3>
        <pre><code>SELECT EXTRACT(YEAR  FROM ts),
       EXTRACT(MONTH FROM ts),
       EXTRACT(DAY   FROM ts);
</code></pre>
      </article>

      <article class="card anchor" id="s4">
        <h2>4）TRUNCATE / ALTER TABLE（PostgreSQL 写法）</h2>
        <div class="two-col">
          <div>
            <h3>TRUNCATE</h3>
            <pre><code>TRUNCATE TABLE table_name RESTART IDENTITY;  -- 重置自增
-- 可选：CASCADE 级联
</code></pre>
          </div>
          <div>
            <h3>列操作（PostgreSQL 没有 MySQL 的 CHANGE/MODIFY/AFTER）</h3>
            <pre><code>-- 添加列
ALTER TABLE t ADD COLUMN name type;

-- 修改类型
ALTER TABLE t ALTER COLUMN name TYPE new_type;

-- 重命名列
ALTER TABLE t RENAME COLUMN old TO new;

-- 设置/取消默认值
ALTER TABLE t ALTER COLUMN name SET DEFAULT ...;
ALTER TABLE t ALTER COLUMN name DROP DEFAULT;

-- 非空/可空
ALTER TABLE t ALTER COLUMN name SET NOT NULL;
ALTER TABLE t ALTER COLUMN name DROP NOT NULL;
</code></pre>
          </div>
        </div>
      </article>

      <article class="card anchor" id="s5">
        <h2>5）窗口函数与窗口帧</h2>
        <h3>常用函数</h3>
        <p><code>SUM</code> / <code>AVG</code> / <code>COUNT</code> / <code>MIN</code> / <code>MAX</code>，<code>ROW_NUMBER</code>，<code>RANK</code>，<code>DENSE_RANK</code>，<code>NTILE(n)</code>，<code>FIRST_VALUE</code>，<code>LAST_VALUE</code>，<code>NTH_VALUE</code>，<code>LAG</code>，<code>LEAD</code></p>
        <h3>窗口帧（ROWS / RANGE）</h3>
        <pre><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
ROWS BETWEEN 3 PRECEDING AND CURRENT ROW

-- 基于值范围（日期/数值）
RANGE BETWEEN INTERVAL '30 days' PRECEDING AND CURRENT ROW
</code></pre>
      </article>

      <article class="card anchor" id="s6">
        <h2>6）JOIN 全家桶</h2>
        <ul>
          <li><b>INNER JOIN：</b> 仅保留匹配行</li>
          <li><b>LEFT JOIN：</b> 左表全部 + 右表匹配，右侧缺失填 NULL</li>
          <li><b>RIGHT JOIN：</b> 右表全部 + 左表匹配</li>
          <li><b>FULL OUTER JOIN：</b> 两侧所有行的并集（MySQL 不支持）</li>
          <li><b>CROSS JOIN：</b> 笛卡尔积</li>
          <li><b>NATURAL JOIN：</b> 同名列自动连接（不透明，生产不推荐）</li>
          <li><b>SELF JOIN：</b> 同表自连接（层级/对比/去重等）</li>
        </ul>
      </article>

      <article class="card anchor" id="s7">
        <h2>7）LIKE / ILIKE 与操作符</h2>
        <ul>
          <li><code>LIKE</code>（区分大小写），<code>ILIKE</code>（不区分大小写）</li>
          <li>等价操作符：<code>~~</code> / <code>!~~</code> / <code>~~*</code> / <code>!~~*</code>（常用写法仍建议 LIKE/ILIKE）</li>
        </ul>
      </article>

      <article class="card anchor" id="s8">
        <h2>8）集合操作：UNION / INTERSECT / EXCEPT</h2>
        <ul>
          <li><b>UNION</b>（去重） / <b>UNION ALL</b>（不去重）</li>
          <li><b>INTERSECT</b>（交集，去重；<code>INTERSECT ALL</code> 保留重复）</li>
          <li><b>EXCEPT</b>（差集，去重；<code>EXCEPT ALL</code> 保留重复）</li>
        </ul>
      </article>

      <article class="card anchor" id="s9">
        <h2>9）GROUPING SETS / CUBE / ROLLUP</h2>
        <pre><code>-- GROUPING SETS：一个查询中进行多种分组
SELECT region, product, SUM(sales)
FROM fact
GROUP BY GROUPING SETS ((region, product), (region), ());

-- CUBE：所有维度的全组合
SELECT region, product, SUM(sales)
FROM fact
GROUP BY CUBE (region, product);

-- ROLLUP：逐级汇总（细 → 粗）
SELECT y, m, SUM(sales)
FROM fact
GROUP BY ROLLUP (y, m);
</code></pre>
      </article>

      <article class="card anchor" id="s10">
        <h2>10）子查询：ANY / ALL / EXISTS / NOT EXISTS</h2>
        <pre><code>-- = ANY 等价于 IN
x = ANY (SELECT id FROM t)

-- &gt; ANY 大于集合最小值； &lt; ANY 小于集合最大值
x &gt; ANY (SELECT val FROM t)

-- ALL：与集合全部比较都成立
x &gt; ALL (SELECT val FROM t)

-- EXISTS：子查询返回至少一行即为 true
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id)

-- NOT EXISTS：查“孤儿数据”
</code></pre>
      </article>

      <article class="card anchor" id="s11">
        <h2>11）CTE 与递归 CTE</h2>
        <pre><code>-- 普通 CTE
WITH c AS (
  SELECT ... FROM ...
)
SELECT * FROM c;

-- 递归 CTE（树/图/层级）
WITH RECURSIVE cte_name AS (
  -- ① 基础查询（起点）
  SELECT ...
  FROM table
  WHERE ...
  UNION ALL
  -- ② 递归部分（自我引用）
  SELECT ...
  FROM table t
  JOIN cte_name c ON t.parent_id = c.id
)
SELECT * FROM cte_name;
</code></pre>
        <ul>
          <li>组织架构、目录树、图遍历、层级路径/深度计算等</li>
        </ul>
      </article>

      <article class="card anchor" id="s12">
        <h2>12）DML：INSERT...SELECT / UPDATE...FROM / UPSERT</h2>
        <div class="two-col">
          <div>
            <h3>INSERT ... SELECT</h3>
            <pre><code>INSERT INTO table(col1, col2)
SELECT col1, col2
FROM another_table
WHERE condition;</code></pre>
          </div>
          <div>
            <h3>UPDATE ... FROM（联表更新）</h3>
            <pre><code>UPDATE a
SET val = b.val
FROM b
WHERE a.id = b.id;</code></pre>
          </div>
        </div>
        <h3>UPSERT（ON CONFLICT）</h3>
        <pre><code>ON CONFLICT ... DO NOTHING  -- 有冲突就跳过
ON CONFLICT ... DO UPDATE   -- 有冲突就更新（EXCLUDED）</code></pre>
      </article>

      <article class="card anchor" id="s13">
        <h2>13）事务</h2>
        <pre><code>BEGIN;   -- BEGIN WORK; / BEGIN TRANSACTION;
  -- DML ...
COMMIT;  -- COMMIT WORK; / COMMIT TRANSACTION;
-- 或者
ROLLBACK;  -- ROLLBACK WORK; / ROLLBACK TRANSACTION;
</code></pre>
      </article>

      <article class="card anchor" id="s14">
        <h2>14）创建数据库与对象大小</h2>
        <h3>创建数据库</h3>
        <pre><code>CREATE DATABASE db_name
  OWNER = role_name
  ENCODING = 'UTF8'
  LC_COLLATE = 'C'
  LC_CTYPE = 'C'
  TABLESPACE = pg_default
  CONNECTION LIMIT = -1;
</code></pre>
        <h3>对象大小</h3>
        <pre><code>SELECT pg_size_pretty(pg_relation_size('table_name'));         -- 表
SELECT pg_size_pretty(pg_total_relation_size('table_name'));   -- 表(含索引/TOAST)
SELECT pg_size_pretty(pg_database_size(current_database()));    -- 库
</code></pre>
      </article>

      <article class="card anchor" id="s15">
        <h2>15）创建表、列/表级约束（PK/FK/UNIQUE/CHECK/NOT NULL）</h2>
        <h3>CREATE TABLE（语法骨架）</h3>
        <pre><code>CREATE TABLE 表名 (
  列名 数据类型 [列的约束],
  [表的约束]
)
INHERITS (已有的表名);  -- 可选：继承
</code></pre>
        <h3>列级约束示例</h3>
        <pre><code>name TEXT NOT NULL
email TEXT UNIQUE
age INTEGER CHECK (age &gt;= 18)
id SERIAL PRIMARY KEY
</code></pre>
        <h3>表级约束示例</h3>
        <pre><code>PRIMARY KEY (id, dept_id)          -- 复合主键
UNIQUE (email, phone)              -- 复合唯一
CHECK (start_date &lt; end_date)      -- 跨列检查
FOREIGN KEY (user_id) REFERENCES users(id)</code></pre>

        <h3 id="s15-pk">PRIMARY KEY（主键）</h3>
        <pre><code>-- 方式 1：单列主键（字段后直接写）
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);

-- 方式 2：显式命名（推荐）
CREATE TABLE users (
  id INTEGER,
  name TEXT,
  CONSTRAINT users_pkey PRIMARY KEY (id)
);

-- 方式 3：联合主键
CREATE TABLE order_items (
  order_id INTEGER,
  item_id  INTEGER,
  CONSTRAINT order_items_pkey PRIMARY KEY (order_id, item_id)
);

-- 方式 4/5：ALTER TABLE 添加主键 / 添加带 SERIAL 的主键列
ALTER TABLE users ADD CONSTRAINT users_pkey PRIMARY KEY (id);
</code></pre>
        <p class="meta">注意：主键列不可为 NULL；添加前需确保数据无重复/NULL；删除主键用 <code>ALTER TABLE ... DROP CONSTRAINT</code>。</p>

        <h3 id="s15-fk">FOREIGN KEY（外键）</h3>
        <pre><code>-- CREATE TABLE 内定义（命名版）
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER,
  CONSTRAINT orders_user_fk FOREIGN KEY (user_id) REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

-- 字段后简写（不命名）
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id)
);

-- 已有表添加外键（推荐显式命名）
ALTER TABLE orders
ADD CONSTRAINT orders_user_fk FOREIGN KEY (user_id) REFERENCES users(id);
</code></pre>
        <p class="meta">ON DELETE/UPDATE：CASCADE / SET NULL / RESTRICT / NO ACTION 等。</p>

        <h3 id="s15-uniq">UNIQUE（唯一约束）</h3>
        <pre><code>-- 列级唯一
email TEXT UNIQUE

-- 表级唯一（命名）
CONSTRAINT unique_email UNIQUE (email)

-- 复合唯一
CONSTRAINT unique_user_email UNIQUE (user_id, email_type)</code></pre>
        <p class="meta">唯一约束允许多个 <code>NULL</code>；自动创建唯一索引。</p>

        <h3 id="s15-check">CHECK（检查约束）</h3>
        <pre><code>age INTEGER CHECK (age BETWEEN 18 AND 65)
salary NUMERIC CHECK (salary &gt; 0)
CHECK (start_date &lt; end_date)
-- 处理 NULL：CHECK (age IS NULL OR age &gt;= 18)</code></pre>

        <h3 id="s15-notnull">NOT NULL（非空）</h3>
        <pre><code>-- 创建时定义
name TEXT NOT NULL

-- 已有表添加/取消
ALTER TABLE users ALTER COLUMN name SET NOT NULL;
ALTER TABLE users ALTER COLUMN name DROP NOT NULL;</code></pre>
      </article>

      <article class="card anchor" id="s16">
        <h2>16）SELECT INTO / CREATE TABLE AS</h2>
        <pre><code>-- 直接用查询结果建表
SELECT * INTO backup_users
FROM users
WHERE is_active = true;

-- 推荐标准写法（更可控）
CREATE TABLE backup_users AS
SELECT * FROM users WHERE is_active = true;</code></pre>
        <p class="meta"><code>SELECT INTO</code> 只能创建新表；插入已有表请用 <code>INSERT INTO ... SELECT ...</code>。</p>
      </article>

      <article class="card anchor" id="s17">
        <h2>17）自增：SERIAL / SEQUENCE / IDENTITY（含管理）</h2>
        <div class="two-col">
          <div>
            <h3>SERIAL（三种）</h3>
            <ul>
              <li><code>SMALLSERIAL</code> → <code>smallint</code></li>
              <li><code>SERIAL</code> → <code>integer</code></li>
              <li><code>BIGSERIAL</code> → <code>bigint</code></li>
            </ul>
            <p class="meta">默认起始值：1；SERIAL 是快捷方式，会创建序列并设默认值。</p>
          </div>
          <div>
            <h3>IDENTITY（SQL 标准，推荐）</h3>
            <pre><code>id INTEGER GENERATED ALWAYS AS IDENTITY
-- 或：BY DEFAULT AS IDENTITY
-- 可选项：START WITH / INCREMENT BY / MINVALUE / MAXVALUE / CYCLE / CACHE</code></pre>
          </div>
        </div>
        <h3>序列（SEQUENCE）</h3>
        <pre><code>CREATE SEQUENCE mysequence INCREMENT 5 START 100;
-- OWNED BY：绑定到表列，删除列/表时自动删除序列
SELECT nextval('mysequence');  -- 100, 105, ...
-- 查询所有序列名
SELECT c.relname AS sequence_name FROM pg_class c WHERE c.relkind = 'S';
-- 删除序列
DROP SEQUENCE IF EXISTS mysequence CASCADE;</code></pre>
        <h3>为已有列添加/修改/删除 IDENTITY</h3>
        <pre><code>ALTER TABLE t ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE t ALTER COLUMN id SET GENERATED BY DEFAULT;
ALTER TABLE t ALTER COLUMN id SET (START WITH 1000, INCREMENT BY 10);
ALTER TABLE t ALTER COLUMN id DROP IDENTITY;</code></pre>
      </article>

      <article class="card anchor" id="s18">
        <h2>18）ALTER TABLE / DROP TABLE</h2>
        <pre><code>-- 多操作合并
ALTER TABLE users
  ADD COLUMN email TEXT,
  DROP COLUMN temp_data,
  RENAME COLUMN full_name TO name;

-- 删除表
DROP TABLE users;
DROP TABLE orders, products;
DROP TABLE IF EXISTS temp_data;   -- 安全删除
DROP TABLE orders CASCADE;        -- 连同依赖</code></pre>
      </article>

      <article class="card anchor" id="s19">
        <h2>19）案例：按日统计售卖率（PostgreSQL 版）</h2>
        <pre><code>SELECT
  DATE '2021-10-01' AS dt,
  ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-25' AND DATE '2021-10-01') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3) AS sale_rate,
  1 - ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-25' AND DATE '2021-10-01') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3) AS unsale_rate
FROM tb_product_info t1
LEFT JOIN tb_order_detail  t2 ON t1.product_id = t2.product_id
LEFT JOIN tb_order_overall t3 ON t2.order_id   = t3.order_id
WHERE shop_id = 901

UNION ALL

SELECT
  DATE '2021-10-02',
  ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-26' AND DATE '2021-10-02') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3),
  1 - ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-26' AND DATE '2021-10-02') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3)
FROM tb_product_info t1
LEFT JOIN tb_order_detail  t2 ON t1.product_id = t2.product_id
LEFT JOIN tb_order_overall t3 ON t2.order_id   = t3.order_id
WHERE shop_id = 901

UNION ALL

SELECT
  DATE '2021-10-03',
  ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-27' AND DATE '2021-10-03') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3),
  1 - ROUND( COUNT(DISTINCT CASE WHEN (t3.event_time::date BETWEEN DATE '2021-09-27' AND DATE '2021-10-03') THEN t2.product_id END)
        / NULLIF(COUNT(DISTINCT t1.product_id)::numeric, 0), 3)
FROM tb_product_info t1
LEFT JOIN tb_order_detail  t2 ON t1.product_id = t2.product_id
LEFT JOIN tb_order_overall t3 ON t2.order_id   = t3.order_id
WHERE shop_id = 901
ORDER BY 1;
</code></pre>
      </article>

      <article class="card anchor" id="s20">
        <h2>20）DISTINCT ON（每组取一行）</h2>
        <pre><code>-- 取每个 user_id 的最新一条记录
SELECT DISTINCT ON (user_id) *
FROM logs
ORDER BY user_id, created_at DESC;
</code></pre>
        <p class="meta">必须结合合适的 <code>ORDER BY</code> 确定每组保留行。</p>
      </article>

      <article class="card anchor" id="s21">
        <h2>21）分页：LIMIT/OFFSET 与锚点翻页</h2>
        <pre><code>-- 传统分页（大偏移性能差）
SELECT ... ORDER BY id LIMIT 20 OFFSET 2000;

-- 锚点式（更高效，基于上次最后一条的 id）
SELECT ... WHERE id &gt; :last_id ORDER BY id LIMIT 20;
</code></pre>
      </article>

      <article class="card anchor" id="s22">
        <h2>22）布尔数据类型（BOOLEAN）</h2>
        <pre><code>CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  is_active BOOLEAN
);

-- 合法写法
INSERT INTO users(is_active) VALUES (TRUE);
INSERT INTO users(is_active) VALUES ('t');
INSERT INTO users(is_active) VALUES (FALSE);

-- 查询
SELECT * FROM users WHERE is_active;        -- 等价于 is_active = TRUE
</code></pre>
        <p class="meta">布尔值等价写法：<code>true/t/yes/y/1</code> 与 <code>false/f/no/n/0</code>；<code>NULL</code> 表示未知。</p>
      </article>

      <article class="card anchor" id="s23">
        <h2>23）字符数据类型</h2>
        <h3>主要类型</h3>
        <ul>
          <li><b>TEXT</b>：不限制长度，推荐</li>
          <li><b>VARCHAR(n)</b>：最大长度为 n，超长插入失败</li>
          <li><b>CHAR(n)</b>：定长，不足补空格（很少使用）</li>
        </ul>
        <pre><code>CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(30),
  full_name TEXT,
  gender CHAR(1)
);

INSERT INTO users (username, full_name, gender)
VALUES ('alice', 'Alice Wonderland', 'F');
</code></pre>
        <h3>常用函数</h3>
        <pre><code>LENGTH(str) / char_length(str)
TRIM(str) / LOWER(str) / UPPER(str)
SUBSTRING(str FROM x FOR y)
CONCAT(a, b)
-- 不区分大小写匹配：ILIKE</code></pre>
      </article>

      <article class="card anchor" id="s24">
        <h2>24）数值类型总览与函数</h2>
        <h3>整数</h3>
        <ul>
          <li><code>SMALLINT</code> / <code>INTEGER</code> / <code>BIGINT</code></li>
        </ul>
        <h3>浮点</h3>
        <ul>
          <li><code>REAL</code>（约 6 位），<code>DOUBLE PRECISION</code>（约 15 位）</li>
        </ul>
        <h3>定点/高精度</h3>
        <ul>
          <li><code>NUMERIC(p, s)</code> / <code>DECIMAL(p, s)</code>（别名）— 金额推荐</li>
        </ul>
        <h3>常用函数/转换</h3>
        <pre><code>ROUND(n, d), CEIL(n), FLOOR(n), ABS(n), POWER(x,y), MOD(x,y)
CAST(... AS type), '123'::INTEGER</code></pre>
        <p class="meta">金融金额类请用 <code>NUMERIC</code>，避免浮点误差。</p>
      </article>

      <article class="card anchor" id="s25">
        <h2>25）整数类型与 SERIAL（强化）</h2>
        <pre><code>CREATE TABLE numbers (
  small_number SMALLINT,
  normal_number INTEGER,
  big_number BIGINT
);

-- 自增（伪类型）
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);
</code></pre>
        <p class="meta">选择建议：小范围 <code>SMALLINT</code>、常用 <code>INTEGER</code>、极大范围 <code>BIGINT</code>。</p>
      </article>

      <article class="card anchor" id="s26">
        <h2>26）日期与时间数据类型（总览）</h2>
        <ul>
          <li><code>DATE</code>、<code>TIME</code>、<code>TIME WITH TIME ZONE</code></li>
          <li><code>TIMESTAMP</code>、<code>TIMESTAMPTZ</code>（带时区）</li>
          <li><code>INTERVAL</code>（时间间隔）</li>
        </ul>
        <pre><code>CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  title TEXT,
  event_date DATE,
  start_time TIME,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 常用
SELECT CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, NOW();
SELECT NOW() + INTERVAL '3 days';

-- 格式化
SELECT to_char(NOW(), 'YYYY-MM-DD HH24:MI:SS');
</code></pre>
      </article>

      <article class="card anchor" id="s27">
        <h2>27）两种时间戳：TIMESTAMP vs TIMESTAMPTZ</h2>
        <pre><code>-- TIMESTAMP：不含时区，原样存储；适合本地事件
-- TIMESTAMPTZ：含时区，UTC 存储、显示按会话时区；适合日志/跨区

SHOW TIME ZONE;
SET TIME ZONE 'Asia/Shanghai';

-- 示例对比（假设系统时区 UTC+8）
-- t1: TIMESTAMP
INSERT INTO t1 (created_at) VALUES ('2025-09-02 14:00:00');  -- 存/显均 14:00:00

-- t2: TIMESTAMPTZ
INSERT INTO t2 (created_at) VALUES ('2025-09-02 14:00:00+08');
-- 实际以 UTC 存 06:00:00，显示为 14:00:00+08
</code></pre>
      </article>

      <article class="card anchor" id="s28">
        <h2>28）INTERVAL（时间间隔）</h2>
        <pre><code>INTERVAL '1 year 2 months 3 days'
INTERVAL '4 hours 30 minutes'

CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  event_name TEXT NOT NULL,
  duration INTERVAL NOT NULL
);

SELECT NOW() + INTERVAL '1 day';
SELECT NOW() - INTERVAL '2 hours';</code></pre>
      </article>

      <article class="card anchor" id="s29">
        <h2>29）UUID</h2>
        <pre><code>CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  username TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE
);

-- 生成函数：uuid_generate_v1(), uuid_generate_v4(), pgcrypto: gen_random_uuid()
</code></pre>
      </article>

      <article class="card anchor" id="s30">
        <h2>30）数组类型</h2>
        <pre><code>CREATE TABLE example (
  id SERIAL PRIMARY KEY,
  tags   TEXT[],
  scores INTEGER[]
);

INSERT INTO example (tags, scores) VALUES
('{red,green,blue}', '{100,90,80}');

-- 访问与函数
SELECT tags[1] FROM example;
SELECT array_length(scores, 1) FROM example;
SELECT unnest(tags) FROM example;

-- 更新元素
UPDATE example SET tags[2] = 'yellow' WHERE id = 1;</code></pre>
      </article>

      <article class="card anchor" id="s31">
        <h2>31）JSON / JSONB</h2>
        <pre><code>CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  data JSONB NOT NULL
);

INSERT INTO documents (data)
VALUES ('{"name": "Alice", "age": 30, "skills": ["SQL", "Python"]}');

-- 提取
SELECT data->>'name' AS name FROM documents;   -- 文本
SELECT data->'skills' AS skills FROM documents;-- JSON

-- 查询包含
SELECT * FROM documents WHERE data @> '{"age": 30}';

-- 更新
UPDATE documents
SET data = jsonb_set(data, '{age}', '31', false)
WHERE id = 1;
</code></pre>
      </article>

      <article class="card anchor" id="s32">
        <h2>32）从 JSON 提取数值并聚合</h2>
        <pre><code>SELECT
  MIN((info->'items'->>'qty')::INTEGER),
  MAX((info->'items'->>'qty')::INTEGER),
  SUM((info->'items'->>'qty')::INTEGER),
  AVG((info->'items'->>'qty')::INTEGER)
FROM orders;
</code></pre>
      </article>

      <article class="card anchor" id="s33">
        <h2>33）Schema 管理</h2>
        <pre><code>-- PostgreSQL 不支持直接重命名 Schema
-- 实现“改名”：新建 + 迁移对象 + 删除旧的
CREATE SCHEMA new_schema_name;

ALTER TABLE old_schema.table_name SET SCHEMA new_schema_name;

DROP SCHEMA old_schema_name [CASCADE | RESTRICT];

ALTER SCHEMA schema_name OWNER TO new_owner;

SET search_path TO schema1, schema2, public;</code></pre>
      </article>

      <article class="card anchor" id="s34">
        <h2>34）COALESCE 笔记</h2>
        <pre><code>-- 简介
-- COALESCE(expr1, expr2, ..., exprN) 返回参数中第一个非 NULL 的值；
-- 常用于为可能为 NULL 的字段设置默认值；
-- 相当于：如果 A 是 NULL 就用 B，否则用 A。

-- 基本语法
COALESCE(value1, value2, ..., valueN)

-- 使用示例
-- 1. 字段为空时显示默认值
SELECT COALESCE(nickname, '无昵称') AS display_name
FROM users;

-- 等价：CASE
SELECT
  CASE
    WHEN nickname IS NOT NULL THEN nickname
    ELSE '无昵称'
  END AS display_name
FROM users;

-- 2. 多字段择一显示（昵称优先，用户名次之）
SELECT COALESCE(nickname, username, '匿名用户') AS display_name
FROM users;

-- 3. 聚合时处理 NULL，防止结果为 NULL
SELECT COALESCE(SUM(score), 0) AS total_score
FROM users;

-- 4. 搭配 NULLIF 使用，替换指定无效值（如 0）为 NULL
SELECT COALESCE(NULLIF(age, 0), 18) AS valid_age
FROM users;

-- 注意事项
-- - 可传入多个参数，按顺序返回第一个非 NULL；
-- - 返回类型为所有参数中数据类型“优先级最高”的类型；
-- - 一旦遇到非 NULL 值，后续参数不再评估（短路机制）；
-- - 可与 NULLIF 结合使用，逻辑更灵活。
</code></pre>
      </article>

      <article class="card anchor" id="s35">
        <h2>35）NULLIF 函数笔记</h2>
        <pre><code>-- 简介
-- NULLIF(expr1, expr2) 如果 expr1 = expr2，则返回 NULL；否则返回 expr1；
-- 常用于避免除以零错误、与 COALESCE 搭配处理特殊值等。

-- 基本语法
NULLIF(value1, value2)

-- 使用示例
-- 1. 避免除以零错误
SELECT total / NULLIF(count, 0) AS avg_value
FROM stats;

-- 2. 与 COALESCE 结合使用：把 0 当作 NULL 处理
SELECT COALESCE(NULLIF(age, 0), 18) AS valid_age
FROM users;

-- 3. 判断两个字段值是否相同
SELECT NULLIF(email, backup_email) AS email_if_different
FROM users;

-- 典型应用
-- 1) 处理非法值（如 0、空字符串）：NULLIF(some_field, 0) → 方便后续 COALESCE
-- 2) 避免运算错误（除以 0）
-- 3) 简化 CASE 判断
-- 注意：若两参数任一为 NULL，则不会返回 NULL，需注意判断逻辑。
</code></pre>
      </article>

      <article class="card anchor" id="s36">
        <h2>36）CAST 笔记</h2>
        <pre><code>-- 用途：将一种数据类型转换成另一种
CAST ( expression AS target_data_type )

-- 示例
SELECT CAST('123' AS INTEGER);
SELECT CAST(123 AS TEXT);
SELECT CAST('2025-09-05' AS DATE);

-- 简写
expression::target_data_type
SELECT '123'::INTEGER;
SELECT 123::TEXT;

-- 注意
-- - 转换失败会抛错，例如 'abc'::INTEGER
-- - 有些转换自动发生（整型↔浮点）
-- 场景：类型不匹配、算术前转换、格式化输出

SELECT
  id,
  price::TEXT AS price_text,
  CAST(created_at AS DATE) AS created_date
FROM products;
</code></pre>
      </article>

      <article class="card anchor" id="s37">
        <h2>37）CASE 表达式简化笔记</h2>
        <pre><code>CASE expression
  WHEN value_1 THEN result_1
  WHEN value_2 THEN result_2
  ...
  ELSE result_n
END

-- 示例
SELECT
  CASE status
    WHEN 'A' THEN 'Active'
    WHEN 'I' THEN 'Inactive'
    ELSE 'Unknown'
  END AS status_desc
FROM users;
</code></pre>
      </article>

      <article class="card anchor" id="s38">
        <h2>38）删除重复数据（DELETE USING 自连接）</h2>
        <pre><code>DELETE
FROM basket a
USING basket b
WHERE
  a.id &lt; b.id            -- 保留 id 较小的
  AND a.fruit = b.fruit; -- 重复判定条件
</code></pre>
        <p class="meta">说明：利用自连接删除重复；条件按业务自定义。</p>
      </article>

      <article class="card anchor" id="s39">
        <h2>39）RANDOM() 产生范围随机数</h2>
        <pre><code>-- RANDOM() 返回 [0,1) 浮点

-- [min, max) 浮点
SELECT RANDOM() * (max - min) + min;

-- [min, max] 整数
SELECT FLOOR(RANDOM() * (max - min + 1)) + min;

-- 示例
SELECT RANDOM() * (20 - 10) + 10;
SELECT FLOOR(RANDOM() * 100) + 1;
</code></pre>
        <p class="meta">需要整数可使用 <code>FLOOR</code> 或显式转换。</p>
      </article>

      <article class="card anchor" id="s40">
        <h2>40）EXPLAIN 语法笔记</h2>
        <pre><code>EXPLAIN [(option [, ...])] sql_statement;

-- 选项
ANALYZE [boolean]
VERBOSE [boolean]
COSTS [boolean]     -- 默认 true
BUFFERS [boolean]
TIMING [boolean]
SUMMARY [boolean]
FORMAT [TEXT|XML|JSON|YAML] -- 默认 TEXT

-- 示例
EXPLAIN ANALYZE VERBOSE SELECT * FROM users WHERE age &gt; 30;

-- 输出常见内容：节点类型（Seq Scan/Index Scan）、估计行数/成本、过滤条件、
-- 实际执行时间（ANALYZE）、缓冲区（BUFFERS）等。
</code></pre>
      </article>

      <article class="card anchor" id="s41">
        <h2>41）PostgreSQL 和 MySQL 对比笔记</h2>
        <pre><code>1. 基本定位
- PostgreSQL：开源对象-关系型数据库，强调标准、扩展性和复杂查询能力。
- MySQL：开源关系型数据库，强调速度、简单与广泛应用。

2. SQL 标准支持
- PostgreSQL：支持更全面（窗口函数、CTE、子查询等）。
- MySQL：旧版本支持较弱。

3. 数据完整性
- PostgreSQL：CHECK、外键、触发器、约束完善。
- MySQL：依引擎差异明显。

4. 并发控制
- PostgreSQL：MVCC 更彻底。
- MySQL：InnoDB 也支持 MVCC。

5. JSON 支持
- PostgreSQL：JSON/JSONB 强大。
- MySQL：5.7 起支持 JSON，功能较弱。

6. 扩展性
- PostgreSQL：自定义函数、类型、索引丰富。
- MySQL：相对较弱。

7. 性能
- PostgreSQL：复杂查询/OLAP 更优。
- MySQL：高并发小查询更轻快。

8. GIS 支持
- PostgreSQL：PostGIS 功能强。
- MySQL：较有限。

9. 工具 & 社区
- MySQL：生态成熟。
- PostgreSQL：社区活跃，增长快。

10. 应用场景
- 选 PG：一致性强、复杂查询、多维分析。
- 选 MySQL：中小型、Web、读多写少。
</code></pre>
      </article>

      <article class="card anchor" id="s42">
        <h2>42）EXCEPT 补充笔记</h2>
        <pre><code>-- 基本语法：
SELECT column1, column2, ...
FROM table1
EXCEPT
SELECT column1, column2, ...
FROM table2;

-- 示例：找出 foo 表中存在但 bar 表中不存在的记录
SELECT ID, name FROM foo
EXCEPT
SELECT ID, name FROM bar;

-- 特点：
-- 1) 默认去重；EXCEPT ALL 保留重复
-- 2) 两个 SELECT 的列数、顺序、类型需一致
-- 3) 常用于数据差异分析、同步校验
</code></pre>
      </article>

      <article class="card anchor" id="s43">
        <h2>43）PL/pgSQL：块结构笔记</h2>
        <pre><code>[ &lt;&lt;label&gt;&gt; ]
DECLARE
    declarations;
BEGIN
    statements;
END [label];

-- 示例
DO $$
DECLARE
  counter INTEGER := 0;
BEGIN
  FOR counter IN 1..5 LOOP
    RAISE NOTICE 'Counter: %', counter;
  END LOOP;
END;
$$;

-- 说明：DECLARE 可选；BEGIN...END 必须；可嵌套；label 可用于流程控制；可带 EXCEPTION。
</code></pre>
      </article>

      <article class="card anchor" id="s44">
        <h2>44）PL/pgSQL：变量笔记</h2>
        <pre><code>-- 声明
DECLARE
  var_name data_type [ := initial_value ];

-- 示例
DECLARE
  user_id INTEGER := 1001;
  user_name TEXT;
  is_active BOOLEAN := TRUE;

-- 使用与赋值
BEGIN
  user_name := 'Alice';
  RAISE NOTICE '用户名：%', user_name;
END;

-- 特殊变量
-- FOUND, SQLSTATE, SQLERRM

-- 赋值方式
total := price * quantity;
SELECT name INTO user_name FROM users WHERE id = user_id;

-- 完整 DO 块
DO $$
DECLARE
  counter INTEGER := 1;
  result  TEXT;
BEGIN
  WHILE counter &lt;= 3 LOOP
    result := '当前值: ' || counter;
    RAISE NOTICE '%', result;
    counter := counter + 1;
  END LOOP;
END;
$$;
</code></pre>
      </article>

      <article class="card anchor" id="s45">
        <h2>45）PL/pgSQL：常量笔记</h2>
        <pre><code>-- 声明
DECLARE
  constant_name CONSTANT data_type := value;

-- 示例
DECLARE
  pi CONSTANT NUMERIC := 3.1415926535;
  max_retry CONSTANT INTEGER := 5;

-- 特点：必须初始化且不可更改；提升可读性与安全性；常用大写命名。
-- 场景：固定配置、数学常量、系统级不变参数。
</code></pre>
      </article>

      <article class="card anchor" id="s46">
        <h2>46）创建存储过程/函数 笔记</h2>
        <pre><code>-- 创建函数
CREATE [OR REPLACE] FUNCTION function_name(parameter_list)
RETURNS return_data_type AS $$
BEGIN
  -- 函数体
  RETURN some_value;
END;
$$ LANGUAGE plpgsql;

-- 示例：
CREATE OR REPLACE FUNCTION get_five()
RETURNS INTEGER AS $$
BEGIN
  RETURN 5;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION add_numbers(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
BEGIN
  RETURN a + b;
END;
$$ LANGUAGE plpgsql;

-- 存储过程（PG 11+）
CREATE [OR REPLACE] PROCEDURE procedure_name(parameter_list)
LANGUAGE plpgsql AS $$
BEGIN
  -- 不返回值，可做事务控制
END;
$$;

-- 调用
SELECT function_name(args);
CALL procedure_name(args);
</code></pre>
      </article>

      <article class="card anchor" id="s47">
        <h2>47）函数的四种参数 笔记</h2>
        <pre><code>-- 1. IN（默认）
CREATE FUNCTION example_in(IN param1 INT)
RETURNS VOID AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;

-- 2. OUT
CREATE FUNCTION example_out(OUT result INT)
AS $$ BEGIN result := 100; END; $$ LANGUAGE plpgsql;

-- 3. INOUT
CREATE FUNCTION example_inout(INOUT param INT)
AS $$ BEGIN param := param + 10; END; $$ LANGUAGE plpgsql;

-- 4. VARIADIC（可变参=数组）
CREATE FUNCTION example_variadic(VARIADIC nums INT[])
RETURNS INT AS $$
DECLARE total INT := 0; n INT;
BEGIN
  FOREACH n IN ARRAY nums LOOP
    total := total + n;
  END LOOP;
  RETURN total;
END;
$$ LANGUAGE plpgsql;
</code></pre>
      </article>

      <article class="card anchor" id="s48">
        <h2>48）函数重载 笔记</h2>
        <pre><code>-- 定义多个同名不同参数列表的函数
CREATE FUNCTION add_value(a INT) RETURNS INT AS $$ BEGIN RETURN a + 10; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION add_value(a INT, b INT) RETURNS INT AS $$ BEGIN RETURN a + b; END; $$ LANGUAGE plpgsql;

-- 调用
SELECT add_value(5);      -- 15（单参版本）
SELECT add_value(5, 3);   -- 8  （双参版本）

-- 注意：区分依据是参数数量/类型；返回类型不同不能单独区分；
-- 自动类型转换可能影响匹配到的重载版本。
</code></pre>
      </article>
      <!-- 49）使用函数返回一张表 -->
<article class="card anchor" id="s49">
  <h2>49）使用函数返回一张表（RETURNS TABLE / RETURN QUERY / RETURN NEXT）</h2>
  <p>适用于封装复杂查询并参数化调用；返回结果可 <code>SELECT * FROM func()</code> 像表一样查询。</p>
  <h3>基本语法</h3>
  <pre><code>CREATE OR REPLACE FUNCTION function_name(param_list)
RETURNS TABLE (
    column1 datatype,
    column2 datatype,
    ...
)
AS $$
BEGIN
    RETURN QUERY
    SELECT ...
    FROM ...;
END;
$$ LANGUAGE plpgsql;
</code></pre>

  <ul>
    <li><code>RETURNS TABLE(...)</code>：定义“表格”结果。</li>
    <li><code>RETURN QUERY</code>：一次性返回整个查询集。</li>
    <li><code>RETURN NEXT</code>：配合循环逐行返回。</li>
  </ul>

  <h3>示例 1：RETURN QUERY</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_film(p_pattern VARCHAR)
RETURNS TABLE (
    film_title VARCHAR,
    film_release_year INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT title, CAST(release_year AS INTEGER)
    FROM film
    WHERE title LIKE p_pattern;
END;
$$ LANGUAGE plpgsql;

-- 调用
SELECT * FROM get_film('A%');
</code></pre>

  <h3>示例 2：LOOP + RETURN NEXT</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_film(p_pattern VARCHAR, p_year INT)
RETURNS TABLE (
    film_title VARCHAR,
    film_release_year INT
) AS $$
DECLARE
    var_r RECORD;
BEGIN
    FOR var_r IN
        SELECT title, release_year
        FROM film
        WHERE title LIKE p_pattern
          AND release_year = p_year
    LOOP
        film_title := UPPER(var_r.title);
        film_release_year := var_r.release_year;
        RETURN NEXT;  -- 逐行返回
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 调用
SELECT * FROM get_film('A%', 2006);
</code></pre>

  <h3>调用建议 &amp; 注意</h3>
  <ul>
    <li>推荐：<code>SELECT * FROM function_name(...)</code>；避免 <code>SELECT function_name(...)</code> 仅得一列复合类型。</li>
    <li><b>不要混用</b> <code>RETURN QUERY</code> 与 <code>RETURN NEXT</code>。</li>
    <li>复杂逐行处理用 <code>RETURN NEXT</code>；简单整集返回用 <code>RETURN QUERY</code>。</li>
  </ul>
</article>

<!-- 50）IF 判断语句 -->
<article class="card anchor" id="s50">
  <h2>50）IF 判断语句</h2>
  <h3>IF / IF ... ELSE / IF ... ELSIF ... ELSE</h3>
  <pre><code>-- IF
DO $$
DECLARE a int := 10; b int := 20;
BEGIN
  IF a &gt; b THEN
    RAISE NOTICE 'a is greater than b';
  END IF;
END $$;

-- IF ELSE
DO $$
DECLARE a int := 10; b int := 20;
BEGIN
  IF a &gt; b THEN
    RAISE NOTICE 'a is greater than b';
  ELSE
    RAISE NOTICE 'a is not greater than b';
  END IF;
END $$;

-- IF ELSIF ELSE
DO $$
DECLARE a int := 10; b int := 10;
BEGIN
  IF a &gt; b THEN
    RAISE NOTICE 'a is greater than b';
  ELSIF a &lt; b THEN
    RAISE NOTICE 'a is less than b';
  ELSE
    RAISE NOTICE 'a is equal to b';
  END IF;
END $$;
</code></pre>
</article>

<!-- 51）CASE 判断语句 -->
<article class="card anchor" id="s51">
  <h2>51）CASE 判断语句（简单 / 可搜索）</h2>
  <h3>1. 简单 CASE</h3>
  <pre><code>-- 语法（PL/pgSQL）
CASE search_expression
  WHEN expression_1 THEN statements
  WHEN expression_2 THEN statements
  ...
  ELSE statements
END CASE;

-- 示例：根据 film_id 获取 price_segment
CREATE OR REPLACE FUNCTION get_price_segment(p_film_id int)
RETURNS VARCHAR(50) AS $$
DECLARE
  rate NUMERIC;
  price_segment VARCHAR(50);
BEGIN
  SELECT rental_rate INTO rate
  FROM film
  WHERE film_id = p_film_id;

  CASE rate
    WHEN 0.99 THEN price_segment := 'Mass';
    WHEN 2.99 THEN price_segment := 'Mainstream';
    WHEN 4.99 THEN price_segment := 'High End';
    ELSE price_segment := 'Unspecified';
  END CASE;

  RETURN price_segment;
END;
$$ LANGUAGE plpgsql;
</code></pre>

  <h3>2. 可搜索 CASE</h3>
  <pre><code>CASE
  WHEN boolean_expr_1 THEN statements
  WHEN boolean_expr_2 THEN statements
  ...
  ELSE statements
END CASE;

-- 示例：根据 customer_id 获取 service_level
CREATE OR REPLACE FUNCTION get_customer_service (p_customer_id int)
RETURNS VARCHAR(25) AS $$
DECLARE
  total_payment NUMERIC;
  service_level VARCHAR(25);
BEGIN
  SELECT SUM(amount) INTO total_payment
  FROM payment
  WHERE customer_id = p_customer_id;

  CASE
    WHEN total_payment &gt; 200 THEN service_level := 'Platinum';
    WHEN total_payment &gt; 100 THEN service_level := 'Gold';
    ELSE service_level := 'Sliver';
  END CASE;

  RETURN service_level;
END;
$$ LANGUAGE plpgsql;

-- 调用示例
SELECT 148 AS customer, get_customer_service(148)
UNION
SELECT 178, get_customer_service(178)
UNION
SELECT 81 , get_customer_service(81);
</code></pre>
</article>

<!-- 52）循环：LOOP / WHILE / FOR -->
<article class="card anchor" id="s52">
  <h2>52）循环：LOOP / WHILE / FOR（含 EXIT / CONTINUE）</h2>
  <h3>LOOP（需 EXIT 退出）</h3>
  <pre><code>DO $$
DECLARE counter int := 0;
BEGIN
  LOOP
    counter := counter + 1;
    EXIT WHEN counter &gt; 5;
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;
</code></pre>

  <h3>WHILE</h3>
  <pre><code>DO $$
DECLARE counter int := 0;
BEGIN
  WHILE counter &lt; 5 LOOP
    counter := counter + 1;
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;
</code></pre>

  <h3>FOR（正向/反向）</h3>
  <pre><code>DO $$
DECLARE counter int;
BEGIN
  FOR counter IN 1..5 LOOP
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;

DO $$
DECLARE counter int;
BEGIN
  FOR counter IN REVERSE 5..1 LOOP
    RAISE NOTICE 'Counter = %', counter;
  END LOOP;
END $$;
</code></pre>

  <h3>EXIT / CONTINUE</h3>
  <pre><code>DO $$
DECLARE counter int := 0;
BEGIN
  LOOP
    counter := counter + 1;
    IF mod(counter, 2) = 0 THEN
      CONTINUE;  -- 跳过偶数
    END IF;
    RAISE NOTICE 'Odd Counter = %', counter;
    EXIT WHEN counter &gt;= 10;
  END LOOP;
END $$;
</code></pre>
</article>

<!-- 53）游标 Cursor -->
<article class="card anchor" id="s53">
  <h2>53）游标 Cursor：显式/隐式、FETCH/MOVE、CURRENT OF、示例</h2>
  <p>游标用于逐行处理查询结果。显式游标更灵活；隐式（<code>FOR ... IN SELECT</code>）更简洁。</p>

  <h3>显式游标示例</h3>
  <pre><code>DO $$
DECLARE
  cur_users CURSOR FOR SELECT id, name FROM users;
  v_id   users.id%TYPE;
  v_name users.name%TYPE;
BEGIN
  OPEN cur_users;
  LOOP
    FETCH cur_users INTO v_id, v_name;
    EXIT WHEN NOT FOUND;      -- FETCH 未取到行
    RAISE NOTICE 'ID: %, Name: %', v_id, v_name;
  END LOOP;
  CLOSE cur_users;
END $$;
</code></pre>

  <h3>隐式游标（FOR 循环）示例</h3>
  <pre><code>DO $$
DECLARE
  user_rec RECORD;
BEGIN
  FOR user_rec IN SELECT id, name FROM users LOOP
    RAISE NOTICE 'ID: %, Name: %', user_rec.id, user_rec.name;
  END LOOP;
END $$;
</code></pre>

  <h3>更多语法要点</h3>
  <pre><code>-- 声明绑定/未绑定游标
DECLARE
  cur_films  CURSOR FOR SELECT * FROM film;
  cur_films2 CURSOR (year int) FOR SELECT * FROM film WHERE release_year = year;
  my_cursor  REFCURSOR;

-- 打开未绑定/动态 SQL
OPEN my_cursor FOR SELECT * FROM city WHERE country = 'US';
OPEN my_cursor FOR EXECUTE 'SELECT * FROM city ORDER BY ' || quote_ident('name');

-- 打开绑定并传参
OPEN cur_films;
OPEN cur_films2(year := 2005);

-- FETCH 方向示例（需 SCROLL）
FETCH NEXT FROM cur_films INTO ...
FETCH PRIOR FROM cur_films INTO ...
FETCH FIRST FROM cur_films INTO ...
FETCH LAST  FROM cur_films INTO ...
FETCH ABSOLUTE 10 FROM cur_films INTO ...
FETCH RELATIVE -1 FROM cur_films INTO ...

-- 只移动不取行
MOVE LAST FROM cur_films;

-- 基于游标定位更新/删除
UPDATE film SET title = title || ' (X)'
WHERE CURRENT OF cur_films;

DELETE FROM film
WHERE CURRENT OF cur_films;

-- 关闭
CLOSE cur_films;
</code></pre>

  <h3>综合示例：按条件累积字符串</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_film_titles(p_year int)
RETURNS text AS $$
DECLARE
  titles   TEXT DEFAULT '';
  rec_film RECORD;
  cur_films CURSOR(p_year int)
    FOR SELECT title, release_year FROM film WHERE release_year = p_year;
BEGIN
  OPEN cur_films(p_year);
  LOOP
    FETCH cur_films INTO rec_film;
    EXIT WHEN NOT FOUND;
    IF rec_film.title LIKE '%ful%' THEN
      titles := titles || ',' || rec_film.title || ':' || rec_film.release_year;
    END IF;
  END LOOP;
  CLOSE cur_films;
  RETURN titles;
END; $$ LANGUAGE plpgsql;

SELECT get_film_titles(2006);
</code></pre>
</article>

<!-- 54）存储过程（PROCEDURE） -->
<article class="card anchor" id="s54">
  <h2>54）存储过程（PROCEDURE）：语法、事务控制、示例、异常处理</h2>
  <ul>
    <li><b>函数 vs 存储过程</b>：PROCEDURE 不作为表达式返回值（不可在 SELECT 中直接用），可执行事务控制（COMMIT/ROLLBACK）。</li>
    <li>调用方式：<code>CALL procedure_name(...)</code></li>
  </ul>

  <h3>创建语法</h3>
  <pre><code>CREATE [ OR REPLACE ] PROCEDURE procedure_name(
  [ [ IN | OUT | INOUT ] arg_name arg_type [, ...] ]
)
LANGUAGE plpgsql AS $$
BEGIN
  -- 逻辑
END;
$$;
</code></pre>

  <h3>示例：写入并提交</h3>
  <pre><code>CREATE OR REPLACE PROCEDURE sp_add_employee(
  IN emp_name TEXT,
  IN emp_salary NUMERIC
)
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO employees(name, salary)
  VALUES (emp_name, emp_salary);
  COMMIT;  -- 过程内可事务控制
END;
$$;

-- 调用
CALL sp_add_employee('Alice', 10000);
</code></pre>

  <h3>示例：带 OUT 参数</h3>
  <pre><code>CREATE OR REPLACE PROCEDURE sp_get_employee_salary(
  IN emp_id INT,
  OUT salary NUMERIC
)
LANGUAGE plpgsql AS $$
BEGIN
  SELECT emp_salary INTO salary FROM employees WHERE id = emp_id;
END;
$$;

-- 调用：CALL sp_get_employee_salary(1, salary_var);
</code></pre>

  <h3>异常处理</h3>
  <pre><code>CREATE OR REPLACE PROCEDURE sp_example()
LANGUAGE plpgsql AS $$
BEGIN
  -- 可能出错的代码
EXCEPTION
  WHEN others THEN
    RAISE NOTICE '发生错误！';
    -- 可回滚/记录日志等
END;
$$;
</code></pre>

  <p class="meta">注意：存储过程不返回值，若需结果集请用 <code>OUT</code> 参数或让过程内部执行 <code>RAISE NOTICE</code>/写入临时表/客户端 FETCH 等策略；需要表达式返回值请使用 <code>FUNCTION</code>。</p>
</article>
<article class="card anchor" id="s55">
  <h2>55）索引的创建</h2>
  <pre><code>一、语法结构
CREATE [UNIQUE] INDEX index_name
ON table_name
[USING method]
(
    column_name [ASC | DESC] [NULLS {FIRST | LAST}],
    ...
);

-- 参数说明：
-- UNIQUE           ：可选，创建唯一索引，强制列值不重复；
-- index_name       ：索引名称，推荐以 idx_开头；
-- table_name       ：要创建索引的表名；
-- USING method     ：索引方法（如 btree、hash、gin、gist 等），默认是 btree；
-- column_name      ：指定要索引的列名；
-- ASC / DESC       ：可选，指定排序方向，默认 ASC；
-- NULLS FIRST/LAST ：可选，指定 NULL 值排序位置（对 ORDER BY 有影响）；

二、基本示例

-- 示例 1：创建一个普通索引
CREATE INDEX idx_users_email
ON users(email);

-- 示例 2：创建唯一索引（用于防止重复）
CREATE UNIQUE INDEX idx_users_username
ON users(username);

-- 示例 3：为多个列创建联合索引
CREATE INDEX idx_orders_customer_date
ON orders(customer_id, order_date);

-- 示例 4：创建带排序规则和 NULL 排序规则的索引
CREATE INDEX idx_users_created_at
ON users(created_at DESC NULLS LAST);

-- 示例 5：使用指定方法（如 hash）创建索引
CREATE INDEX idx_users_email_hash
ON users USING hash(email);

三、使用建议

-- 适合创建索引的场景：
-- - WHERE 子句中频繁使用的列；
-- - JOIN 中用作连接键的列；
-- - ORDER BY / GROUP BY 中使用的列；
-- - 外键列或需要唯一约束的列；

-- 注意事项：
-- - 创建索引会占用额外的存储空间；
-- - 对频繁更新的表，索引过多可能影响写入性能；
-- - 不建议为小表创建过多索引，可能得不偿失；
-- - 索引名应简洁、具有可读性，一般采用：idx_表名_列名；

-- 索引命名建议：
-- idx_表名_列名，例如：idx_users_email、idx_orders_date

四、创建并发索引（PostgreSQL 12+）

-- 不阻塞写操作的索引创建方式（但不能在事务中执行）：
CREATE INDEX CONCURRENTLY idx_users_last_login
ON users(last_login);

-- 注意：CONCURRENTLY 不能放在 BEGIN ... COMMIT 块中！

五、查看索引信息

-- 查看表上已有的索引：
\d tablename

-- 查看所有索引：
SELECT * FROM pg_indexes WHERE tablename = 'your_table_name';

-- 查看索引大小（按 MB 统计）：
SELECT 
    relname AS index_name,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE relname LIKE 'idx_%';

-- 查看某索引的定义：
SELECT indexdef 
FROM pg_indexes 
WHERE indexname = 'idx_users_email';
</code></pre>
</article>

<article class="card anchor" id="s56">
  <h2>56）删除索引</h2>
  <pre><code>一、标准语法结构
DROP INDEX [CONCURRENTLY]
           [IF EXISTS] index_name
           [CASCADE | RESTRICT];

-- 参数说明：
-- CONCURRENTLY：在不锁表的情况下删除索引，适合生产环境；
-- IF EXISTS    ：避免索引不存在时报错；
-- CASCADE      ：自动删除依赖该索引的对象（如外键/约束）；
-- RESTRICT     ：默认行为，若存在依赖则阻止删除（更安全）；

二、基本示例

-- 示例 1：删除一个索引（常规写法）
DROP INDEX idx_users_email;

-- 示例 2：删除前判断是否存在
DROP INDEX IF EXISTS idx_orders_customer_date;

-- 示例 3：非阻塞方式删除索引（不会锁住表，不能在事务中执行）
DROP INDEX CONCURRENTLY idx_logs_event_time;

-- 示例 4：强制删除索引及其依赖对象
DROP INDEX idx_customers_contact CASCADE;

-- 示例 5：防止误删（默认行为）
DROP INDEX idx_customers_contact RESTRICT;

三、使用 CONCURRENTLY 的注意事项

-- CONCURRENTLY 用于避免锁表，但有以下限制：
-- - 不能在事务块（BEGIN ... COMMIT）中执行；
-- - 删除速度比常规慢；
-- - 删除期间仍允许 DML 操作（如 INSERT / UPDATE / DELETE）；

-- 示例（错误写法，会报错）：
BEGIN;
DROP INDEX CONCURRENTLY idx_users_email;  -- ❌ 不允许
COMMIT;

-- 正确用法（必须独立执行）：
DROP INDEX CONCURRENTLY idx_users_email;

四、查看现有索引

-- 查看表上的索引：
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'your_table_name';

-- 查看索引使用频率：
SELECT 
    relname AS index_name,
    idx_scan AS times_used
FROM pg_stat_user_indexes
WHERE relname = 'idx_users_email';

五、总结建议

-- ✔ 删除前先检查索引是否仍被查询使用；
-- ✔ 删除唯一约束的索引，请使用 ALTER TABLE DROP CONSTRAINT；
-- ✔ 对大表删除索引时建议使用 CONCURRENTLY；
-- ❌ 不建议频繁删除和重建索引，会影响性能与存储；
-- ✔ 删除无效、不常用、重复的索引，可提升写入效率。
</code></pre>
</article>

<!-- ……中间省略，直到 s76 -->

<article class="card anchor" id="s76">
  <h2>76）表空间修改和删除</h2>
  <pre><code>一、修改表空间
-- 语法
ALTER TABLESPACE tablespace_name
    RENAME TO new_tablespace_name;

ALTER TABLESPACE tablespace_name
    OWNER TO new_owner;

-- 示例：修改表空间名称
ALTER TABLESPACE myspace RENAME TO myspace_new;

-- 示例：修改表空间所有者
ALTER TABLESPACE myspace OWNER TO postgres;

二、删除表空间
-- 语法
DROP TABLESPACE [IF EXISTS] tablespace_name;

-- 示例：删除一个表空间
DROP TABLESPACE myspace;

-- 示例：安全删除（不存在时不报错）
DROP TABLESPACE IF EXISTS myspace;

三、注意事项
-- - 删除表空间前需确保没有数据库对象存放其中；
-- - 若有依赖对象需转移或删除，否则 DROP 会失败；
-- - 修改表空间不会移动已存储的数据文件；
-- - 表空间的物理目录不会自动删除，需手动清理。
</code></pre>
</article>

    </section>
  </div>
</body>
</html>
